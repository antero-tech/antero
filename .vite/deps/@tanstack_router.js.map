{
  "version": 3,
  "sources": ["../../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js", "../../node_modules/use-sync-external-store/shim/index.js", "../../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js", "../../node_modules/use-sync-external-store/shim/with-selector.js", "../../node_modules/tiny-invariant/dist/esm/tiny-invariant.js", "../../node_modules/tiny-warning/dist/tiny-warning.esm.js", "../../node_modules/@tanstack/store/src/index.ts", "../../node_modules/@tanstack/react-store/src/index.tsx", "../../node_modules/@tanstack/router/src/history.ts", "../../node_modules/@tanstack/router/src/utils.ts", "../../node_modules/@tanstack/router/src/path.ts", "../../node_modules/@tanstack/router/src/qss.ts", "../../node_modules/@tanstack/router/src/react.tsx", "../../node_modules/@tanstack/router/src/route.ts", "../../node_modules/@tanstack/router/src/searchParams.ts", "../../node_modules/@tanstack/router/src/router.ts", "../../node_modules/@tanstack/router/src/routeMatch.ts"],
  "sourcesContent": ["/**\n * @license React\n * use-sync-external-store-shim.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function() {\n\n          'use strict';\n\n/* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\nif (\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart ===\n    'function'\n) {\n  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n}\n          var React = require('react');\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nfunction error(format) {\n  {\n    {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      printWarning('error', format, args);\n    }\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n    var argsWithFormat = args.map(function (item) {\n      return String(item);\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\n/**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */\nfunction is(x, y) {\n  return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare\n  ;\n}\n\nvar objectIs = typeof Object.is === 'function' ? Object.is : is;\n\n// dispatch for CommonJS interop named imports.\n\nvar useState = React.useState,\n    useEffect = React.useEffect,\n    useLayoutEffect = React.useLayoutEffect,\n    useDebugValue = React.useDebugValue;\nvar didWarnOld18Alpha = false;\nvar didWarnUncachedGetSnapshot = false; // Disclaimer: This shim breaks many of the rules of React, and only works\n// because of a very particular set of implementation details and assumptions\n// -- change any one of them and it will break. The most important assumption\n// is that updates are always synchronous, because concurrent rendering is\n// only available in versions of React that also have a built-in\n// useSyncExternalStore API. And we only use this shim when the built-in API\n// does not exist.\n//\n// Do not assume that the clever hacks used by this hook also work in general.\n// The point of this shim is to replace the need for hacks by other libraries.\n\nfunction useSyncExternalStore(subscribe, getSnapshot, // Note: The shim does not use getServerSnapshot, because pre-18 versions of\n// React do not expose a way to check if we're hydrating. So users of the shim\n// will need to track that themselves and return the correct value\n// from `getSnapshot`.\ngetServerSnapshot) {\n  {\n    if (!didWarnOld18Alpha) {\n      if (React.startTransition !== undefined) {\n        didWarnOld18Alpha = true;\n\n        error('You are using an outdated, pre-release alpha of React 18 that ' + 'does not support useSyncExternalStore. The ' + 'use-sync-external-store shim will not work correctly. Upgrade ' + 'to a newer pre-release.');\n      }\n    }\n  } // Read the current snapshot from the store on every render. Again, this\n  // breaks the rules of React, and only works here because of specific\n  // implementation details, most importantly that updates are\n  // always synchronous.\n\n\n  var value = getSnapshot();\n\n  {\n    if (!didWarnUncachedGetSnapshot) {\n      var cachedValue = getSnapshot();\n\n      if (!objectIs(value, cachedValue)) {\n        error('The result of getSnapshot should be cached to avoid an infinite loop');\n\n        didWarnUncachedGetSnapshot = true;\n      }\n    }\n  } // Because updates are synchronous, we don't queue them. Instead we force a\n  // re-render whenever the subscribed state changes by updating an some\n  // arbitrary useState hook. Then, during render, we call getSnapshot to read\n  // the current value.\n  //\n  // Because we don't actually use the state returned by the useState hook, we\n  // can save a bit of memory by storing other stuff in that slot.\n  //\n  // To implement the early bailout, we need to track some things on a mutable\n  // object. Usually, we would put that in a useRef hook, but we can stash it in\n  // our useState hook instead.\n  //\n  // To force a re-render, we call forceUpdate({inst}). That works because the\n  // new object always fails an equality check.\n\n\n  var _useState = useState({\n    inst: {\n      value: value,\n      getSnapshot: getSnapshot\n    }\n  }),\n      inst = _useState[0].inst,\n      forceUpdate = _useState[1]; // Track the latest getSnapshot function with a ref. This needs to be updated\n  // in the layout phase so we can access it during the tearing check that\n  // happens on subscribe.\n\n\n  useLayoutEffect(function () {\n    inst.value = value;\n    inst.getSnapshot = getSnapshot; // Whenever getSnapshot or subscribe changes, we need to check in the\n    // commit phase if there was an interleaved mutation. In concurrent mode\n    // this can happen all the time, but even in synchronous mode, an earlier\n    // effect may have mutated the store.\n\n    if (checkIfSnapshotChanged(inst)) {\n      // Force a re-render.\n      forceUpdate({\n        inst: inst\n      });\n    }\n  }, [subscribe, value, getSnapshot]);\n  useEffect(function () {\n    // Check for changes right before subscribing. Subsequent changes will be\n    // detected in the subscription handler.\n    if (checkIfSnapshotChanged(inst)) {\n      // Force a re-render.\n      forceUpdate({\n        inst: inst\n      });\n    }\n\n    var handleStoreChange = function () {\n      // TODO: Because there is no cross-renderer API for batching updates, it's\n      // up to the consumer of this library to wrap their subscription event\n      // with unstable_batchedUpdates. Should we try to detect when this isn't\n      // the case and print a warning in development?\n      // The store changed. Check if the snapshot changed since the last time we\n      // read from the store.\n      if (checkIfSnapshotChanged(inst)) {\n        // Force a re-render.\n        forceUpdate({\n          inst: inst\n        });\n      }\n    }; // Subscribe to the store and return a clean-up function.\n\n\n    return subscribe(handleStoreChange);\n  }, [subscribe]);\n  useDebugValue(value);\n  return value;\n}\n\nfunction checkIfSnapshotChanged(inst) {\n  var latestGetSnapshot = inst.getSnapshot;\n  var prevValue = inst.value;\n\n  try {\n    var nextValue = latestGetSnapshot();\n    return !objectIs(prevValue, nextValue);\n  } catch (error) {\n    return true;\n  }\n}\n\nfunction useSyncExternalStore$1(subscribe, getSnapshot, getServerSnapshot) {\n  // Note: The shim does not use getServerSnapshot, because pre-18 versions of\n  // React do not expose a way to check if we're hydrating. So users of the shim\n  // will need to track that themselves and return the correct value\n  // from `getSnapshot`.\n  return getSnapshot();\n}\n\nvar canUseDOM = !!(typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined');\n\nvar isServerEnvironment = !canUseDOM;\n\nvar shim = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore;\nvar useSyncExternalStore$2 = React.useSyncExternalStore !== undefined ? React.useSyncExternalStore : shim;\n\nexports.useSyncExternalStore = useSyncExternalStore$2;\n          /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\nif (\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop ===\n    'function'\n) {\n  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n}\n        \n  })();\n}\n", "'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('../cjs/use-sync-external-store-shim.production.min.js');\n} else {\n  module.exports = require('../cjs/use-sync-external-store-shim.development.js');\n}\n", "/**\n * @license React\n * use-sync-external-store-shim/with-selector.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function() {\n\n          'use strict';\n\n/* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\nif (\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart ===\n    'function'\n) {\n  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n}\n          var React = require('react');\nvar shim = require('use-sync-external-store/shim');\n\n/**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */\nfunction is(x, y) {\n  return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare\n  ;\n}\n\nvar objectIs = typeof Object.is === 'function' ? Object.is : is;\n\nvar useSyncExternalStore = shim.useSyncExternalStore;\n\n// for CommonJS interop.\n\nvar useRef = React.useRef,\n    useEffect = React.useEffect,\n    useMemo = React.useMemo,\n    useDebugValue = React.useDebugValue; // Same as useSyncExternalStore, but supports selector and isEqual arguments.\n\nfunction useSyncExternalStoreWithSelector(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {\n  // Use this to track the rendered snapshot.\n  var instRef = useRef(null);\n  var inst;\n\n  if (instRef.current === null) {\n    inst = {\n      hasValue: false,\n      value: null\n    };\n    instRef.current = inst;\n  } else {\n    inst = instRef.current;\n  }\n\n  var _useMemo = useMemo(function () {\n    // Track the memoized state using closure variables that are local to this\n    // memoized instance of a getSnapshot function. Intentionally not using a\n    // useRef hook, because that state would be shared across all concurrent\n    // copies of the hook/component.\n    var hasMemo = false;\n    var memoizedSnapshot;\n    var memoizedSelection;\n\n    var memoizedSelector = function (nextSnapshot) {\n      if (!hasMemo) {\n        // The first time the hook is called, there is no memoized result.\n        hasMemo = true;\n        memoizedSnapshot = nextSnapshot;\n\n        var _nextSelection = selector(nextSnapshot);\n\n        if (isEqual !== undefined) {\n          // Even if the selector has changed, the currently rendered selection\n          // may be equal to the new selection. We should attempt to reuse the\n          // current value if possible, to preserve downstream memoizations.\n          if (inst.hasValue) {\n            var currentSelection = inst.value;\n\n            if (isEqual(currentSelection, _nextSelection)) {\n              memoizedSelection = currentSelection;\n              return currentSelection;\n            }\n          }\n        }\n\n        memoizedSelection = _nextSelection;\n        return _nextSelection;\n      } // We may be able to reuse the previous invocation's result.\n\n\n      // We may be able to reuse the previous invocation's result.\n      var prevSnapshot = memoizedSnapshot;\n      var prevSelection = memoizedSelection;\n\n      if (objectIs(prevSnapshot, nextSnapshot)) {\n        // The snapshot is the same as last time. Reuse the previous selection.\n        return prevSelection;\n      } // The snapshot has changed, so we need to compute a new selection.\n\n\n      // The snapshot has changed, so we need to compute a new selection.\n      var nextSelection = selector(nextSnapshot); // If a custom isEqual function is provided, use that to check if the data\n      // has changed. If it hasn't, return the previous selection. That signals\n      // to React that the selections are conceptually equal, and we can bail\n      // out of rendering.\n\n      // If a custom isEqual function is provided, use that to check if the data\n      // has changed. If it hasn't, return the previous selection. That signals\n      // to React that the selections are conceptually equal, and we can bail\n      // out of rendering.\n      if (isEqual !== undefined && isEqual(prevSelection, nextSelection)) {\n        return prevSelection;\n      }\n\n      memoizedSnapshot = nextSnapshot;\n      memoizedSelection = nextSelection;\n      return nextSelection;\n    }; // Assigning this to a constant so that Flow knows it can't change.\n\n\n    // Assigning this to a constant so that Flow knows it can't change.\n    var maybeGetServerSnapshot = getServerSnapshot === undefined ? null : getServerSnapshot;\n\n    var getSnapshotWithSelector = function () {\n      return memoizedSelector(getSnapshot());\n    };\n\n    var getServerSnapshotWithSelector = maybeGetServerSnapshot === null ? undefined : function () {\n      return memoizedSelector(maybeGetServerSnapshot());\n    };\n    return [getSnapshotWithSelector, getServerSnapshotWithSelector];\n  }, [getSnapshot, getServerSnapshot, selector, isEqual]),\n      getSelection = _useMemo[0],\n      getServerSelection = _useMemo[1];\n\n  var value = useSyncExternalStore(subscribe, getSelection, getServerSelection);\n  useEffect(function () {\n    inst.hasValue = true;\n    inst.value = value;\n  }, [value]);\n  useDebugValue(value);\n  return value;\n}\n\nexports.useSyncExternalStoreWithSelector = useSyncExternalStoreWithSelector;\n          /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\nif (\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop ===\n    'function'\n) {\n  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n}\n        \n  })();\n}\n", "'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('../cjs/use-sync-external-store-shim/with-selector.production.min.js');\n} else {\n  module.exports = require('../cjs/use-sync-external-store-shim/with-selector.development.js');\n}\n", "var isProduction = process.env.NODE_ENV === 'production';\nvar prefix = 'Invariant failed';\nfunction invariant(condition, message) {\n    if (condition) {\n        return;\n    }\n    if (isProduction) {\n        throw new Error(prefix);\n    }\n    var provided = typeof message === 'function' ? message() : message;\n    var value = provided ? \"\".concat(prefix, \": \").concat(provided) : prefix;\n    throw new Error(value);\n}\n\nexport { invariant as default };\n", "var isProduction = process.env.NODE_ENV === 'production';\nfunction warning(condition, message) {\n  if (!isProduction) {\n    if (condition) {\n      return;\n    }\n\n    var text = \"Warning: \" + message;\n\n    if (typeof console !== 'undefined') {\n      console.warn(text);\n    }\n\n    try {\n      throw Error(text);\n    } catch (x) {}\n  }\n}\n\nexport default warning;\n", "export type AnyUpdater = (...args: any[]) => any\n\nexport type Listener<TState> = (next: TState, prev: TState) => void\n\ninterface StoreOptions<\n  TState,\n  TUpdater extends AnyUpdater = (cb: TState) => TState,\n> {\n  updateFn?: (previous: TState) => (updater: TUpdater) => TState\n  onSubscribe?: (\n    listener: Listener<TState>,\n    store: Store<TState, TUpdater>,\n  ) => () => void\n  onUpdate?: (next: TState, prev: TState) => void\n}\n\nexport class Store<\n  TState,\n  TUpdater extends AnyUpdater = (cb: TState) => TState,\n> {\n  listeners = new Set<Listener<TState>>()\n  state: TState\n  options?: StoreOptions<TState, TUpdater>\n  #batching = false\n  #flushing = 0\n\n  constructor(initialState: TState, options?: StoreOptions<TState, TUpdater>) {\n    this.state = initialState\n    this.options = options\n  }\n\n  subscribe = (listener: Listener<TState>) => {\n    this.listeners.add(listener)\n    const unsub = this.options?.onSubscribe?.(listener, this)\n    return () => {\n      this.listeners.delete(listener)\n      unsub?.()\n    }\n  }\n\n  setState = (updater: TUpdater) => {\n    const previous = this.state\n    this.state = this.options?.updateFn\n      ? this.options.updateFn(previous)(updater)\n      : (updater as any)(previous)\n\n    if (this.state === previous) return\n\n    this.options?.onUpdate?.(this.state, previous)\n\n    this.#flush(previous)\n  }\n\n  #flush = (previous: TState) => {\n    if (this.#batching) return\n    const flushId = ++this.#flushing\n    this.listeners.forEach((listener) => {\n      if (this.#flushing !== flushId) return\n      listener(this.state, previous)\n    })\n  }\n\n  batch = (cb: () => void) => {\n    if (this.#batching) return cb()\n    const previous = this.state\n    this.#batching = true\n    cb()\n    this.#batching = false\n    this.#flush(previous)\n  }\n}\n", "import { AnyUpdater, Store } from '@tanstack/store'\nimport { useSyncExternalStoreWithSelector } from 'use-sync-external-store/shim/with-selector'\n\nexport * from '@tanstack/store'\n\nexport type NoInfer<T> = [T][T extends any ? 0 : never]\n\nexport function useStore<\n  TState,\n  TSelected = NoInfer<TState>,\n  TUpdater extends AnyUpdater = AnyUpdater,\n>(\n  store: Store<TState, TUpdater>,\n  selector: (state: NoInfer<TState>) => TSelected = (d) => d as any,\n) {\n  const slice = useSyncExternalStoreWithSelector(\n    store.subscribe,\n    () => store.state,\n    () => store.state,\n    selector,\n    shallow,\n  )\n\n  return slice\n}\n\nexport function shallow<T>(objA: T, objB: T) {\n  if (Object.is(objA, objB)) {\n    return true\n  }\n\n  if (\n    typeof objA !== 'object' ||\n    objA === null ||\n    typeof objB !== 'object' ||\n    objB === null\n  ) {\n    return false\n  }\n\n  const keysA = Object.keys(objA)\n  if (keysA.length !== Object.keys(objB).length) {\n    return false\n  }\n\n  for (let i = 0; i < keysA.length; i++) {\n    if (\n      !Object.prototype.hasOwnProperty.call(objB, keysA[i] as string) ||\n      !Object.is(objA[keysA[i] as keyof T], objB[keysA[i] as keyof T])\n    ) {\n      return false\n    }\n  }\n  return true\n}\n", "// While the public API was clearly inspired by the \"history\" npm package,\n// This implementation attempts to be more lightweight by\n// making assumptions about the way TanStack Router works\n\nexport interface RouterHistory {\n  location: RouterLocation\n  listen: (cb: () => void) => () => void\n  push: (path: string, state: any) => void\n  replace: (path: string, state: any) => void\n  go: (index: number) => void\n  back: () => void\n  forward: () => void\n  createHref: (href: string) => string\n  block: (blockerFn: BlockerFn) => () => void\n}\n\nexport interface ParsedPath {\n  href: string\n  pathname: string\n  search: string\n  hash: string\n}\n\nexport interface RouterLocation extends ParsedPath {\n  state: any\n}\n\ntype BlockerFn = (retry: () => void, cancel: () => void) => void\n\nconst popStateEvent = 'popstate'\nconst beforeUnloadEvent = 'beforeunload'\n\nconst beforeUnloadListener = (event: Event) => {\n  event.preventDefault()\n  // @ts-ignore\n  return (event.returnValue = '')\n}\n\nconst stopBlocking = () => {\n  removeEventListener(beforeUnloadEvent, beforeUnloadListener, {\n    capture: true,\n  })\n}\n\nfunction createHistory(opts: {\n  getLocation: () => RouterLocation\n  listener: (onUpdate: () => void) => () => void\n  pushState: (path: string, state: any) => void\n  replaceState: (path: string, state: any) => void\n  go: (n: number) => void\n  back: () => void\n  forward: () => void\n  createHref: (path: string) => string\n}): RouterHistory {\n  let currentLocation = opts.getLocation()\n  let unsub = () => {}\n  let listeners = new Set<() => void>()\n  let blockers: BlockerFn[] = []\n  let queue: (() => void)[] = []\n\n  const tryFlush = () => {\n    if (blockers.length) {\n      blockers[0]?.(tryFlush, () => {\n        blockers = []\n        stopBlocking()\n      })\n      return\n    }\n\n    while (queue.length) {\n      queue.shift()?.()\n    }\n\n    onUpdate()\n  }\n\n  const queueTask = (task: () => void) => {\n    queue.push(task)\n    tryFlush()\n  }\n\n  const onUpdate = () => {\n    currentLocation = opts.getLocation()\n    listeners.forEach((listener) => listener())\n  }\n\n  return {\n    get location() {\n      return currentLocation\n    },\n    listen: (cb: () => void) => {\n      if (listeners.size === 0) {\n        unsub = opts.listener(onUpdate)\n      }\n      listeners.add(cb)\n\n      return () => {\n        listeners.delete(cb)\n        if (listeners.size === 0) {\n          unsub()\n        }\n      }\n    },\n    push: (path: string, state: any) => {\n      queueTask(() => {\n        opts.pushState(path, state)\n      })\n    },\n    replace: (path: string, state: any) => {\n      queueTask(() => {\n        opts.replaceState(path, state)\n      })\n    },\n    go: (index) => {\n      queueTask(() => {\n        opts.go(index)\n      })\n    },\n    back: () => {\n      queueTask(() => {\n        opts.back()\n      })\n    },\n    forward: () => {\n      queueTask(() => {\n        opts.forward()\n      })\n    },\n    createHref: (str) => opts.createHref(str),\n    block: (cb) => {\n      blockers.push(cb)\n\n      if (blockers.length === 1) {\n        addEventListener(beforeUnloadEvent, beforeUnloadListener, {\n          capture: true,\n        })\n      }\n\n      return () => {\n        blockers = blockers.filter((b) => b !== cb)\n\n        if (!blockers.length) {\n          stopBlocking()\n        }\n      }\n    },\n  }\n}\n\nexport function createBrowserHistory(opts?: {\n  getHref?: () => string\n  createHref?: (path: string) => string\n}): RouterHistory {\n  const getHref =\n    opts?.getHref ??\n    (() =>\n      `${window.location.pathname}${window.location.hash}${window.location.search}`)\n  const createHref = opts?.createHref ?? ((path) => path)\n  const getLocation = () => parseLocation(getHref(), history.state)\n\n  return createHistory({\n    getLocation,\n    listener: (onUpdate) => {\n      window.addEventListener(popStateEvent, onUpdate)\n      return () => {\n        window.removeEventListener(popStateEvent, onUpdate)\n      }\n    },\n    pushState: (path, state) => {\n      window.history.pushState(\n        { ...state, key: createRandomKey() },\n        '',\n        createHref(path),\n      )\n    },\n    replaceState: (path, state) => {\n      window.history.replaceState(\n        { ...state, key: createRandomKey() },\n        '',\n        createHref(path),\n      )\n    },\n    back: () => window.history.back(),\n    forward: () => window.history.forward(),\n    go: (n) => window.history.go(n),\n    createHref: (path) => createHref(path),\n  })\n}\n\nexport function createHashHistory(): RouterHistory {\n  return createBrowserHistory({\n    getHref: () => window.location.hash.substring(1),\n    createHref: (path) => `#${path}`,\n  })\n}\n\nexport function createMemoryHistory(\n  opts: {\n    initialEntries: string[]\n    initialIndex?: number\n  } = {\n    initialEntries: ['/'],\n  },\n): RouterHistory {\n  const entries = opts.initialEntries\n  let index = opts.initialIndex ?? entries.length - 1\n  let currentState = {}\n\n  const getLocation = () => parseLocation(entries[index]!, currentState)\n\n  return createHistory({\n    getLocation,\n    listener: () => {\n      return () => {}\n    },\n    pushState: (path, state) => {\n      currentState = {\n        ...state,\n        key: createRandomKey(),\n      }\n      entries.push(path)\n      index++\n    },\n    replaceState: (path, state) => {\n      currentState = {\n        ...state,\n        key: createRandomKey(),\n      }\n      entries[index] = path\n    },\n    back: () => {\n      index--\n    },\n    forward: () => {\n      index = Math.min(index + 1, entries.length - 1)\n    },\n    go: (n) => window.history.go(n),\n    createHref: (path) => path,\n  })\n}\n\nfunction parseLocation(href: string, state: any): RouterLocation {\n  let hashIndex = href.indexOf('#')\n  let searchIndex = href.indexOf('?')\n\n  return {\n    href,\n    pathname: href.substring(\n      0,\n      hashIndex > 0\n        ? searchIndex > 0\n          ? Math.min(hashIndex, searchIndex)\n          : hashIndex\n        : searchIndex > 0\n        ? searchIndex\n        : href.length,\n    ),\n    hash: hashIndex > -1 ? href.substring(hashIndex, searchIndex) : '',\n    search: searchIndex > -1 ? href.substring(searchIndex) : '',\n    state,\n  }\n}\n\n// Thanks co-pilot!\nfunction createRandomKey() {\n  return (Math.random() + 1).toString(36).substring(7)\n}\n", "export type NoInfer<T> = [T][T extends any ? 0 : never]\nexport type IsAny<T, Y, N> = 1 extends 0 & T ? Y : N\nexport type IsAnyBoolean<T> = 1 extends 0 & T ? true : false\nexport type IsKnown<T, Y, N> = unknown extends T ? N : Y\nexport type PickAsRequired<T, K extends keyof T> = Omit<T, K> &\n  Required<Pick<T, K>>\nexport type PickAsPartial<T, K extends keyof T> = Omit<T, K> &\n  Partial<Pick<T, K>>\nexport type PickUnsafe<T, K> = K extends keyof T ? Pick<T, K> : never\nexport type PickExtra<T, K> = {\n  [TKey in keyof K as string extends TKey\n    ? never\n    : TKey extends keyof T\n    ? never\n    : TKey]: K[TKey]\n}\n\nexport type PickRequired<T> = {\n  [K in keyof T as undefined extends T[K] ? never : K]: T[K]\n}\n\nexport type Expand<T> = T extends object\n  ? T extends infer O\n    ? { [K in keyof O]: O[K] }\n    : never\n  : T\n\nexport type UnionToIntersection<U> = (\n  U extends any ? (k: U) => void : never\n) extends (k: infer I) => any\n  ? I\n  : never\n\ntype Compute<T> = { [K in keyof T]: T[K] } | never\n\ntype AllKeys<T> = T extends any ? keyof T : never\n\nexport type MergeUnion<T, Keys extends keyof T = keyof T> = Compute<\n  {\n    [K in Keys]: T[Keys]\n  } & {\n    [K in AllKeys<T>]?: T extends any\n      ? K extends keyof T\n        ? T[K]\n        : never\n      : never\n  }\n>\n\nexport type Values<O> = O[ValueKeys<O>]\nexport type ValueKeys<O> = Extract<keyof O, PropertyKey>\n\nexport type DeepAwaited<T> = T extends Promise<infer A>\n  ? DeepAwaited<A>\n  : T extends Record<infer A, Promise<infer B>>\n  ? { [K in A]: DeepAwaited<B> }\n  : T\n\nexport type PathParamMask<TRoutePath extends string> =\n  TRoutePath extends `${infer L}/$${infer C}/${infer R}`\n    ? PathParamMask<`${L}/${string}/${R}`>\n    : TRoutePath extends `${infer L}/$${infer C}`\n    ? PathParamMask<`${L}/${string}`>\n    : TRoutePath\n\nexport type Timeout = ReturnType<typeof setTimeout>\n\nexport type Updater<TPrevious, TResult = TPrevious> =\n  | TResult\n  | ((prev?: TPrevious) => TResult)\n\nexport type PickExtract<T, U> = {\n  [K in keyof T as T[K] extends U ? K : never]: T[K]\n}\n\nexport type PickExclude<T, U> = {\n  [K in keyof T as T[K] extends U ? never : K]: T[K]\n}\n\nexport function last<T>(arr: T[]) {\n  return arr[arr.length - 1]\n}\n\nfunction isFunction(d: any): d is Function {\n  return typeof d === 'function'\n}\n\nexport function functionalUpdate<TResult>(\n  updater: Updater<TResult>,\n  previous: TResult,\n) {\n  if (isFunction(updater)) {\n    return updater(previous as TResult)\n  }\n\n  return updater\n}\n\nexport function pick<T, K extends keyof T>(parent: T, keys: K[]): Pick<T, K> {\n  return keys.reduce((obj: any, key: K) => {\n    obj[key] = parent[key]\n    return obj\n  }, {} as any)\n}\n\n/**\n * This function returns `a` if `b` is deeply equal.\n * If not, it will replace any deeply equal children of `b` with those of `a`.\n * This can be used for structural sharing between immutable JSON values for example.\n * Do not use this with signals\n */\nexport function replaceEqualDeep<T>(prev: any, _next: T): T {\n  if (prev === _next) {\n    return prev\n  }\n\n  const next = _next as any\n\n  const array = Array.isArray(prev) && Array.isArray(next)\n\n  if (array || (isPlainObject(prev) && isPlainObject(next))) {\n    const prevSize = array ? prev.length : Object.keys(prev).length\n    const nextItems = array ? next : Object.keys(next)\n    const nextSize = nextItems.length\n    const copy: any = array ? [] : {}\n\n    let equalItems = 0\n\n    for (let i = 0; i < nextSize; i++) {\n      const key = array ? i : nextItems[i]\n      copy[key] = replaceEqualDeep(prev[key], next[key])\n      if (copy[key] === prev[key]) {\n        equalItems++\n      }\n    }\n\n    return prevSize === nextSize && equalItems === prevSize ? prev : copy\n  }\n\n  return next\n}\n\n// Copied from: https://github.com/jonschlinkert/is-plain-object\nexport function isPlainObject(o: any) {\n  if (!hasObjectPrototype(o)) {\n    return false\n  }\n\n  // If has modified constructor\n  const ctor = o.constructor\n  if (typeof ctor === 'undefined') {\n    return true\n  }\n\n  // If has modified prototype\n  const prot = ctor.prototype\n  if (!hasObjectPrototype(prot)) {\n    return false\n  }\n\n  // If constructor does not have an Object-specific method\n  if (!prot.hasOwnProperty('isPrototypeOf')) {\n    return false\n  }\n\n  // Most likely a plain Object\n  return true\n}\n\nfunction hasObjectPrototype(o: any) {\n  return Object.prototype.toString.call(o) === '[object Object]'\n}\n\nexport function partialDeepEqual(a: any, b: any): boolean {\n  if (a === b) {\n    return true\n  }\n\n  if (typeof a !== typeof b) {\n    return false\n  }\n\n  if (isPlainObject(a) && isPlainObject(b)) {\n    return !Object.keys(b).some((key) => !partialDeepEqual(a[key], b[key]))\n  }\n\n  if (Array.isArray(a) && Array.isArray(b)) {\n    return (\n      a.length === b.length &&\n      a.every((item, index) => partialDeepEqual(item, b[index]))\n    )\n  }\n\n  return false\n}\n", "import { AnyPathParams } from './route'\nimport { MatchLocation } from './router'\nimport { last } from './utils'\n\nexport interface Segment {\n  type: 'pathname' | 'param' | 'wildcard'\n  value: string\n}\n\nexport function joinPaths(paths: (string | undefined)[]) {\n  return cleanPath(paths.filter(Boolean).join('/'))\n}\n\nexport function cleanPath(path: string) {\n  // remove double slashes\n  return path.replace(/\\/{2,}/g, '/')\n}\n\nexport function trimPathLeft(path: string) {\n  return path === '/' ? path : path.replace(/^\\/{1,}/, '')\n}\n\nexport function trimPathRight(path: string) {\n  return path === '/' ? path : path.replace(/\\/{1,}$/, '')\n}\n\nexport function trimPath(path: string) {\n  return trimPathRight(trimPathLeft(path))\n}\n\nexport function resolvePath(basepath: string, base: string, to: string) {\n  base = base.replace(new RegExp(`^${basepath}`), '/')\n  to = to.replace(new RegExp(`^${basepath}`), '/')\n\n  let baseSegments = parsePathname(base)\n  const toSegments = parsePathname(to)\n\n  toSegments.forEach((toSegment, index) => {\n    if (toSegment.value === '/') {\n      if (!index) {\n        // Leading slash\n        baseSegments = [toSegment]\n      } else if (index === toSegments.length - 1) {\n        // Trailing Slash\n        baseSegments.push(toSegment)\n      } else {\n        // ignore inter-slashes\n      }\n    } else if (toSegment.value === '..') {\n      // Extra trailing slash? pop it off\n      if (baseSegments.length > 1 && last(baseSegments)?.value === '/') {\n        baseSegments.pop()\n      }\n      baseSegments.pop()\n    } else if (toSegment.value === '.') {\n      return\n    } else {\n      baseSegments.push(toSegment)\n    }\n  })\n\n  const joined = joinPaths([basepath, ...baseSegments.map((d) => d.value)])\n\n  return cleanPath(joined)\n}\n\nexport function parsePathname(pathname?: string): Segment[] {\n  if (!pathname) {\n    return []\n  }\n\n  pathname = cleanPath(pathname)\n\n  const segments: Segment[] = []\n\n  if (pathname.slice(0, 1) === '/') {\n    pathname = pathname.substring(1)\n    segments.push({\n      type: 'pathname',\n      value: '/',\n    })\n  }\n\n  if (!pathname) {\n    return segments\n  }\n\n  // Remove empty segments and '.' segments\n  const split = pathname.split('/').filter(Boolean)\n\n  segments.push(\n    ...split.map((part): Segment => {\n      if (part === '$' || part === '*') {\n        return {\n          type: 'wildcard',\n          value: part,\n        }\n      }\n\n      if (part.charAt(0) === '$') {\n        return {\n          type: 'param',\n          value: part,\n        }\n      }\n\n      return {\n        type: 'pathname',\n        value: part,\n      }\n    }),\n  )\n\n  if (pathname.slice(-1) === '/') {\n    pathname = pathname.substring(1)\n    segments.push({\n      type: 'pathname',\n      value: '/',\n    })\n  }\n\n  return segments\n}\n\nexport function interpolatePath(\n  path: string | undefined,\n  params: any,\n  leaveWildcard?: boolean,\n) {\n  const interpolatedPathSegments = parsePathname(path)\n\n  return joinPaths(\n    interpolatedPathSegments.map((segment) => {\n      if (['$', '*'].includes(segment.value) && !leaveWildcard) {\n        return ''\n      }\n\n      if (segment.type === 'param') {\n        return params![segment.value.substring(1)] ?? ''\n      }\n\n      return segment.value\n    }),\n  )\n}\n\nexport function matchPathname(\n  basepath: string,\n  currentPathname: string,\n  matchLocation: Pick<MatchLocation, 'to' | 'fuzzy' | 'caseSensitive'>,\n): AnyPathParams | undefined {\n  const pathParams = matchByPath(basepath, currentPathname, matchLocation)\n  // const searchMatched = matchBySearch(currentLocation.search, matchLocation)\n\n  if (matchLocation.to && !pathParams) {\n    return\n  }\n\n  return pathParams ?? {}\n}\n\nexport function matchByPath(\n  basepath: string,\n  from: string,\n  matchLocation: Pick<MatchLocation, 'to' | 'caseSensitive' | 'fuzzy'>,\n): Record<string, string> | undefined {\n  if (!from.startsWith(basepath)) {\n    return undefined\n  }\n  from = basepath != '/' ? from.substring(basepath.length) : from\n  const baseSegments = parsePathname(from)\n  const to = `${matchLocation.to ?? '$'}`\n  const routeSegments = parsePathname(to)\n\n  if (last(baseSegments)?.value === '/') {\n    baseSegments.pop()\n  }\n\n  const params: Record<string, string> = {}\n\n  let isMatch = (() => {\n    for (\n      let i = 0;\n      i < Math.max(baseSegments.length, routeSegments.length);\n      i++\n    ) {\n      const baseSegment = baseSegments[i]\n      const routeSegment = routeSegments[i]\n\n      const isLastRouteSegment = i === routeSegments.length - 1\n      const isLastBaseSegment = i === baseSegments.length - 1\n\n      if (routeSegment) {\n        if (routeSegment.type === 'wildcard') {\n          if (baseSegment?.value) {\n            params['*'] = joinPaths(baseSegments.slice(i).map((d) => d.value))\n            return true\n          }\n          return false\n        }\n\n        if (routeSegment.type === 'pathname') {\n          if (routeSegment.value === '/' && !baseSegment?.value) {\n            return true\n          }\n\n          if (baseSegment) {\n            if (matchLocation.caseSensitive) {\n              if (routeSegment.value !== baseSegment.value) {\n                return false\n              }\n            } else if (\n              routeSegment.value.toLowerCase() !==\n              baseSegment.value.toLowerCase()\n            ) {\n              return false\n            }\n          }\n        }\n\n        if (!baseSegment) {\n          return false\n        }\n\n        if (routeSegment.type === 'param') {\n          if (baseSegment?.value === '/') {\n            return false\n          }\n          if (baseSegment.value.charAt(0) !== '$') {\n            params[routeSegment.value.substring(1)] = baseSegment.value\n          }\n        }\n      }\n\n      if (isLastRouteSegment && !isLastBaseSegment) {\n        return !!matchLocation.fuzzy\n      }\n    }\n    return true\n  })()\n\n  return isMatch ? (params as Record<string, string>) : undefined\n}\n", "// @ts-nocheck\n\n// qss has been slightly modified and inlined here for our use cases (and compression's sake). We've included it as a hard dependency for MIT license attribution.\n\nexport function encode(obj, pfx?: string) {\n  var k,\n    i,\n    tmp,\n    str = ''\n\n  for (k in obj) {\n    if ((tmp = obj[k]) !== void 0) {\n      if (Array.isArray(tmp)) {\n        for (i = 0; i < tmp.length; i++) {\n          str && (str += '&')\n          str += encodeURIComponent(k) + '=' + encodeURIComponent(tmp[i])\n        }\n      } else {\n        str && (str += '&')\n        str += encodeURIComponent(k) + '=' + encodeURIComponent(tmp)\n      }\n    }\n  }\n\n  return (pfx || '') + str\n}\n\nfunction toValue(mix) {\n  if (!mix) return ''\n  var str = decodeURIComponent(mix)\n  if (str === 'false') return false\n  if (str === 'true') return true\n  if (str.charAt(0) === '0') return str\n  return +str * 0 === 0 ? +str : str\n}\n\nexport function decode(str) {\n  var tmp,\n    k,\n    out = {},\n    arr = str.split('&')\n\n  while ((tmp = arr.shift())) {\n    tmp = tmp.split('=')\n    k = tmp.shift()\n    if (out[k] !== void 0) {\n      out[k] = [].concat(out[k], toValue(tmp.shift()))\n    } else {\n      out[k] = toValue(tmp.shift())\n    }\n  }\n\n  return out\n}\n", "import * as React from 'react'\nimport { NoInfer, useStore } from '@tanstack/react-store'\nimport invariant from 'tiny-invariant'\nimport warning from 'tiny-warning'\nimport {\n  LinkOptions,\n  ToOptions,\n  ResolveRelativePath,\n  ValidFromPath,\n  NavigateOptions,\n} from './link'\nimport { AnyRootRoute, AnyRoute, RootRoute, Route } from './route'\nimport {\n  RouteByPath,\n  AnyRoutesInfo,\n  RoutesInfo,\n  DefaultRoutesInfo,\n} from './routeInfo'\nimport { AnyRouteMatch, RouteMatch } from './routeMatch'\nimport {\n  RegisteredRoutesInfo,\n  MatchRouteOptions,\n  RegisteredRouter,\n  RouterConstructorOptions,\n  RouterOptions,\n  RouterState,\n  Router,\n} from './router'\nimport { functionalUpdate, last } from './utils'\n\n//\n\nexport { useStore }\n\n//\n\ntype ReactNode = any\n\nexport type SyncRouteComponent<TProps = {}> = (props: TProps) => ReactNode\n\nexport type RouteComponent<TProps = {}> = SyncRouteComponent<TProps> & {\n  preload?: () => Promise<void>\n}\n\nexport function lazy(\n  importer: () => Promise<{ default: SyncRouteComponent }>,\n): RouteComponent {\n  const lazyComp = React.lazy(importer as any)\n  let preloaded: Promise<SyncRouteComponent>\n\n  const finalComp = lazyComp as unknown as RouteComponent\n\n  finalComp.preload = async () => {\n    if (!preloaded) {\n      await importer()\n    }\n  }\n\n  return finalComp\n}\n\nexport type LinkPropsOptions<\n  TFrom extends RegisteredRoutesInfo['routePaths'] = '/',\n  TTo extends string = '',\n> = LinkOptions<RegisteredRoutesInfo, TFrom, TTo> & {\n  // A function that returns additional props for the `active` state of this link. These props override other props passed to the link (`style`'s are merged, `className`'s are concatenated)\n  activeProps?:\n    | React.AnchorHTMLAttributes<HTMLAnchorElement>\n    | (() => React.AnchorHTMLAttributes<HTMLAnchorElement>)\n  // A function that returns additional props for the `inactive` state of this link. These props override other props passed to the link (`style`'s are merged, `className`'s are concatenated)\n  inactiveProps?:\n    | React.AnchorHTMLAttributes<HTMLAnchorElement>\n    | (() => React.AnchorHTMLAttributes<HTMLAnchorElement>)\n}\n\nexport type MakeUseMatchRouteOptions<\n  TFrom extends RegisteredRoutesInfo['routePaths'] = '/',\n  TTo extends string = '',\n> = ToOptions<RegisteredRoutesInfo, TFrom, TTo> & MatchRouteOptions\n\nexport type MakeMatchRouteOptions<\n  TFrom extends RegisteredRoutesInfo['routePaths'] = '/',\n  TTo extends string = '',\n> = ToOptions<RegisteredRoutesInfo, TFrom, TTo> &\n  MatchRouteOptions & {\n    // If a function is passed as a child, it will be given the `isActive` boolean to aid in further styling on the element it returns\n    children?:\n      | ReactNode\n      | ((\n          params: RouteByPath<\n            RegisteredRoutesInfo,\n            ResolveRelativePath<TFrom, NoInfer<TTo>>\n          >['__types']['allParams'],\n        ) => ReactNode)\n  }\n\nexport type MakeLinkPropsOptions<\n  TFrom extends ValidFromPath<RegisteredRoutesInfo> = '/',\n  TTo extends string = '',\n> = LinkPropsOptions<TFrom, TTo> & React.AnchorHTMLAttributes<HTMLAnchorElement>\n\nexport type MakeLinkOptions<\n  TFrom extends RegisteredRoutesInfo['routePaths'] = '/',\n  TTo extends string = '',\n> = LinkPropsOptions<TFrom, TTo> &\n  React.AnchorHTMLAttributes<HTMLAnchorElement> &\n  Omit<React.AnchorHTMLAttributes<HTMLAnchorElement>, 'children'> & {\n    // If a function is passed as a child, it will be given the `isActive` boolean to aid in further styling on the element it returns\n    children?: ReactNode | ((state: { isActive: boolean }) => ReactNode)\n  }\n\nexport type PromptProps = {\n  message: string\n  condition?: boolean | any\n  children?: ReactNode\n}\n\n//\n\nexport function useLinkProps<\n  TFrom extends ValidFromPath<RegisteredRoutesInfo> = '/',\n  TTo extends string = '',\n>(\n  options: MakeLinkPropsOptions<TFrom, TTo>,\n): React.AnchorHTMLAttributes<HTMLAnchorElement> {\n  const router = useRouterContext()\n\n  const {\n    // custom props\n    type,\n    children,\n    target,\n    activeProps = () => ({ className: 'active' }),\n    inactiveProps = () => ({}),\n    activeOptions,\n    disabled,\n    // fromCurrent,\n    hash,\n    search,\n    params,\n    to = '.',\n    preload,\n    preloadDelay,\n    replace,\n    // element props\n    style,\n    className,\n    onClick,\n    onFocus,\n    onMouseEnter,\n    onMouseLeave,\n    onTouchStart,\n    ...rest\n  } = options\n\n  const linkInfo = router.buildLink(options as any)\n\n  if (linkInfo.type === 'external') {\n    const { href } = linkInfo\n    return { href }\n  }\n\n  const {\n    handleClick,\n    handleFocus,\n    handleEnter,\n    handleLeave,\n    handleTouchStart,\n    isActive,\n    next,\n  } = linkInfo\n\n  const reactHandleClick = (e: Event) => {\n    if (React.startTransition) {\n      // This is a hack for react < 18\n      React.startTransition(() => {\n        handleClick(e)\n      })\n    } else {\n      handleClick(e)\n    }\n  }\n\n  const composeHandlers =\n    (handlers: (undefined | ((e: any) => void))[]) =>\n    (e: React.SyntheticEvent) => {\n      if (e.persist) e.persist()\n      handlers.filter(Boolean).forEach((handler) => {\n        if (e.defaultPrevented) return\n        handler!(e)\n      })\n    }\n\n  // Get the active props\n  const resolvedActiveProps: React.HTMLAttributes<HTMLAnchorElement> = isActive\n    ? functionalUpdate(activeProps as any, {}) ?? {}\n    : {}\n\n  // Get the inactive props\n  const resolvedInactiveProps: React.HTMLAttributes<HTMLAnchorElement> =\n    isActive ? {} : functionalUpdate(inactiveProps, {}) ?? {}\n\n  return {\n    ...resolvedActiveProps,\n    ...resolvedInactiveProps,\n    ...rest,\n    href: disabled ? undefined : next.href,\n    onClick: composeHandlers([onClick, reactHandleClick]),\n    onFocus: composeHandlers([onFocus, handleFocus]),\n    onMouseEnter: composeHandlers([onMouseEnter, handleEnter]),\n    onMouseLeave: composeHandlers([onMouseLeave, handleLeave]),\n    onTouchStart: composeHandlers([onTouchStart, handleTouchStart]),\n    target,\n    style: {\n      ...style,\n      ...resolvedActiveProps.style,\n      ...resolvedInactiveProps.style,\n    },\n    className:\n      [\n        className,\n        resolvedActiveProps.className,\n        resolvedInactiveProps.className,\n      ]\n        .filter(Boolean)\n        .join(' ') || undefined,\n    ...(disabled\n      ? {\n          role: 'link',\n          'aria-disabled': true,\n        }\n      : undefined),\n    ['data-status']: isActive ? 'active' : undefined,\n  }\n}\n\nexport interface LinkFn<\n  TDefaultFrom extends RegisteredRoutesInfo['routePaths'] = '/',\n  TDefaultTo extends string = '',\n> {\n  <\n    TFrom extends RegisteredRoutesInfo['routePaths'] = TDefaultFrom,\n    TTo extends string = TDefaultTo,\n  >(\n    props: MakeLinkOptions<TFrom, TTo> & React.RefAttributes<HTMLAnchorElement>,\n  ): ReactNode\n}\n\nexport const Link: LinkFn = React.forwardRef((props: any, ref) => {\n  const linkProps = useLinkProps(props)\n\n  return (\n    <a\n      {...{\n        ref: ref as any,\n        ...linkProps,\n        children:\n          typeof props.children === 'function'\n            ? props.children({\n                isActive: (linkProps as any)['data-status'] === 'active',\n              })\n            : props.children,\n      }}\n    />\n  )\n}) as any\n\nexport function Navigate<\n  TFrom extends RegisteredRoutesInfo['routePaths'] = '/',\n  TTo extends string = '',\n>(props: NavigateOptions<RegisteredRoutesInfo, TFrom, TTo>): null {\n  const router = useRouterContext()\n\n  React.useLayoutEffect(() => {\n    router.navigate(props as any)\n  }, [])\n\n  return null\n}\n\ntype MatchesContextValue = AnyRouteMatch[]\n\nexport const matchesContext = React.createContext<MatchesContextValue>(null!)\nexport const routerContext = React.createContext<{ router: RegisteredRouter }>(\n  null!,\n)\n\nexport type MatchesProviderProps = {\n  value: MatchesContextValue\n  children: ReactNode\n}\n\nexport type RouterProps<\n  TRouteConfig extends AnyRoute = AnyRoute,\n  TRoutesInfo extends AnyRoutesInfo = DefaultRoutesInfo,\n  TDehydrated extends Record<string, any> = Record<string, any>,\n> = RouterOptions<TRouteConfig, TDehydrated> & {\n  router: Router<TRouteConfig, TRoutesInfo>\n}\n\nexport function RouterProvider<\n  TRouteConfig extends AnyRoute = AnyRoute,\n  TRoutesInfo extends AnyRoutesInfo = DefaultRoutesInfo,\n  TDehydrated extends Record<string, any> = Record<string, any>,\n>({ router, ...rest }: RouterProps<TRouteConfig, TRoutesInfo, TDehydrated>) {\n  router.update(rest)\n\n  const currentMatches = useStore(router.__store, (s) => s.currentMatches)\n\n  React.useEffect(router.mount, [router])\n\n  return (\n    <routerContext.Provider value={{ router: router as any }}>\n      <matchesContext.Provider value={[undefined!, ...currentMatches]}>\n        <CatchBoundary\n          errorComponent={ErrorComponent}\n          onCatch={() => {\n            warning(\n              false,\n              `Error in router! Consider setting an 'errorComponent' in your RootRoute! 👍`,\n            )\n          }}\n        >\n          <Outlet />\n        </CatchBoundary>\n      </matchesContext.Provider>\n    </routerContext.Provider>\n  )\n}\n\nexport function useRouterContext(): RegisteredRouter {\n  const value = React.useContext(routerContext)\n  warning(value, 'useRouter must be used inside a <Router> component!')\n\n  useStore(value.router.__store)\n\n  return value.router\n}\n\nexport function useRouter<T = RouterState>(\n  track?: (state: Router['__store']) => T,\n): RegisteredRouter {\n  const router = useRouterContext()\n  useStore(router.__store, track as any)\n  return router\n}\n\nexport function useMatches(): RouteMatch[] {\n  return React.useContext(matchesContext)\n}\n\nexport function useMatch<\n  TFrom extends keyof RegisteredRoutesInfo['routesById'],\n  TStrict extends boolean = true,\n  TRouteMatch = RouteMatch<\n    RegisteredRoutesInfo,\n    RegisteredRoutesInfo['routesById'][TFrom]\n  >,\n>(opts?: {\n  from: TFrom\n  strict?: TStrict\n  track?: (match: TRouteMatch) => any\n}): TStrict extends true ? TRouteMatch : TRouteMatch | undefined {\n  const router = useRouterContext()\n  const nearestMatch = useMatches()[0]!\n  const match = opts?.from\n    ? router.state.currentMatches.find((d) => d.route.id === opts?.from)\n    : nearestMatch\n\n  invariant(\n    match,\n    `Could not find ${\n      opts?.from ? `an active match from \"${opts.from}\"` : 'a nearest match!'\n    }`,\n  )\n\n  if (opts?.strict ?? true) {\n    invariant(\n      nearestMatch.route.id == match?.route.id,\n      `useMatch(\"${\n        match?.route.id as string\n      }\") is being called in a component that is meant to render the '${\n        nearestMatch.route.id\n      }' route. Did you mean to 'useMatch(\"${\n        match?.route.id as string\n      }\", { strict: false })' or 'useRoute(\"${\n        match?.route.id as string\n      }\")' instead?`,\n    )\n  }\n\n  useStore(match!.__store as any, (d) => opts?.track?.(match as any) ?? match)\n\n  return match as any\n}\n\n// export function useRoute<\n//   TId extends keyof RegisteredRoutesInfo['routesById'] = '/',\n// >(routeId: TId): RegisteredRoutesInfo['routesById'][TId] {\n//   const router = useRouterContext()\n//   const resolvedRoute = router.getRoute(routeId as any)\n\n//   invariant(\n//     resolvedRoute,\n//     `Could not find a route for route \"${\n//       routeId as string\n//     }\"! Did you forget to add it to your route?`,\n//   )\n\n//   return resolvedRoute as any\n// }\n\nexport type RouteFromIdOrRoute<T> = T extends RegisteredRoutesInfo['routeUnion']\n  ? T\n  : T extends keyof RegisteredRoutesInfo['routesById']\n  ? RegisteredRoutesInfo['routesById'][T]\n  : T extends string\n  ? keyof RegisteredRoutesInfo['routesById']\n  : never\n\n// export function useRoute<TRouteOrId>(\n//   route: TRouteOrId extends string\n//     ? keyof RegisteredRoutesInfo['routeIds']\n//     : RegisteredRoutesInfo['routeUnion'],\n// ): RouteFromIdOrRoute<TRouteOrId> {\n//   return null as any\n// }\n\nexport function useLoader<\n  TFrom extends keyof RegisteredRoutesInfo['routesById'],\n  TStrict extends boolean = true,\n  TLoader = RegisteredRoutesInfo['routesById'][TFrom]['__types']['loader'],\n  TSelected = TLoader,\n>(opts?: {\n  from: TFrom\n  strict?: TStrict\n  track?: (search: TLoader) => TSelected\n}): TStrict extends true ? TSelected : TSelected | undefined {\n  const { track, ...matchOpts } = opts as any\n  const match = useMatch(matchOpts)\n  useStore(match.__store, (d: any) => opts?.track?.(d.loader) ?? d.loader)\n  return (match as unknown as RouteMatch).state.loader as any\n}\n\nexport function useSearch<\n  TFrom extends keyof RegisteredRoutesInfo['routesById'],\n  TStrict extends boolean = true,\n  TSearch = RegisteredRoutesInfo['routesById'][TFrom]['__types']['fullSearchSchema'],\n  TSelected = TSearch,\n>(opts?: {\n  from: TFrom\n  strict?: TStrict\n  track?: (search: TSearch) => TSelected\n}): TStrict extends true ? TSelected : TSelected | undefined {\n  const { track, ...matchOpts } = opts as any\n  const match = useMatch(matchOpts)\n  useStore(match.__store, (d: any) => opts?.track?.(d.search) ?? d.search)\n\n  return (match as unknown as RouteMatch).state.search as any\n}\n\nexport function useParams<\n  TFrom extends keyof RegisteredRoutesInfo['routesById'] = '/',\n  TDefaultSelected = RegisteredRoutesInfo['allParams'] &\n    RegisteredRoutesInfo['routesById'][TFrom]['__types']['allParams'],\n  TSelected = TDefaultSelected,\n>(opts?: {\n  from: TFrom\n  track?: (search: TDefaultSelected) => TSelected\n}): TSelected {\n  const router = useRouterContext()\n  useStore(router.__store, (d) => {\n    const params = last(d.currentMatches)?.params as any\n    return opts?.track?.(params) ?? params\n  })\n\n  return last(router.state.currentMatches)?.params as any\n}\n\nexport function useNavigate<\n  TDefaultFrom extends keyof RegisteredRoutesInfo['routesById'] = '/',\n>(defaultOpts?: { from?: TDefaultFrom }) {\n  const router = useRouterContext()\n  return React.useCallback(\n    <\n      TFrom extends keyof RegisteredRoutesInfo['routesById'] = TDefaultFrom,\n      TTo extends string = '',\n    >(\n      opts?: MakeLinkOptions<TFrom, TTo>,\n    ) => {\n      return router.navigate({ ...defaultOpts, ...(opts as any) })\n    },\n    [],\n  )\n}\n\nexport function useMatchRoute() {\n  const router = useRouterContext()\n\n  return React.useCallback(\n    <\n      TFrom extends ValidFromPath<RegisteredRoutesInfo> = '/',\n      TTo extends string = '',\n    >(\n      opts: MakeUseMatchRouteOptions<TFrom, TTo>,\n    ) => {\n      const { pending, caseSensitive, ...rest } = opts\n\n      return router.matchRoute(rest as any, {\n        pending,\n        caseSensitive,\n      })\n    },\n    [],\n  )\n}\n\nexport function MatchRoute<\n  TFrom extends ValidFromPath<RegisteredRoutesInfo> = '/',\n  TTo extends string = '',\n>(props: MakeMatchRouteOptions<TFrom, TTo>): any {\n  const matchRoute = useMatchRoute()\n  const params = matchRoute(props)\n\n  if (!params) {\n    return null\n  }\n\n  if (typeof props.children === 'function') {\n    return (props.children as any)(params)\n  }\n\n  return params ? props.children : null\n}\n\nexport function Outlet() {\n  const matches = useMatches().slice(1)\n  const match = matches[0]\n\n  if (!match) {\n    return null\n  }\n\n  return <SubOutlet matches={matches} match={match} />\n}\n\nfunction SubOutlet({\n  matches,\n  match,\n}: {\n  matches: RouteMatch[]\n  match: RouteMatch\n}) {\n  const router = useRouterContext()\n  useStore(match!.__store, (store) => [store.status, store.error])\n\n  const defaultPending = React.useCallback(() => null, [])\n\n  const PendingComponent = (match.pendingComponent ??\n    router.options.defaultPendingComponent ??\n    defaultPending) as any\n\n  const errorComponent =\n    match.errorComponent ?? router.options.defaultErrorComponent\n\n  const ResolvedSuspenseBoundary =\n    match.route.options.wrapInSuspense ?? true ? React.Suspense : SafeFragment\n  const ResolvedCatchBoundary = errorComponent ? CatchBoundary : SafeFragment\n\n  return (\n    <matchesContext.Provider value={matches}>\n      <ResolvedSuspenseBoundary fallback={<PendingComponent />}>\n        <ResolvedCatchBoundary\n          key={match.route.id}\n          errorComponent={errorComponent}\n          onCatch={() => {\n            warning(false, `Error in route match: ${match.id}`)\n          }}\n        >\n          <Inner match={match} />\n        </ResolvedCatchBoundary>\n      </ResolvedSuspenseBoundary>\n    </matchesContext.Provider>\n  )\n}\n\nfunction Inner(props: { match: RouteMatch }): any {\n  const router = useRouterContext()\n\n  if (props.match.state.status === 'error') {\n    throw props.match.state.error\n  }\n\n  if (props.match.state.status === 'pending') {\n    throw props.match.__loadPromise\n  }\n\n  if (props.match.state.status === 'success') {\n    return React.createElement(\n      props.match.component ?? router.options.defaultComponent ?? Outlet,\n      {\n        useLoader: props.match.route.useLoader,\n        useMatch: props.match.route.useMatch,\n        useContext: props.match.route.useContext,\n        useSearch: props.match.route.useSearch,\n      },\n    )\n  }\n\n  invariant(\n    false,\n    'Idle routeMatch status encountered during rendering! You should never see this. File an issue!',\n  )\n}\n\nfunction SafeFragment(props: any) {\n  return <>{props.children}</>\n}\n\n// This is the messiest thing ever... I'm either seriously tired (likely) or\n// there has to be a better way to reset error boundaries when the\n// router's location key changes.\n\nclass CatchBoundary extends React.Component<{\n  children: any\n  errorComponent: any\n  onCatch: (error: any, info: any) => void\n}> {\n  state = {\n    error: false,\n    info: undefined,\n  }\n  componentDidCatch(error: any, info: any) {\n    this.props.onCatch(error, info)\n    console.error(error)\n    this.setState({\n      error,\n      info,\n    })\n  }\n  render() {\n    return (\n      <CatchBoundaryInner\n        {...this.props}\n        errorState={this.state}\n        reset={() => this.setState({})}\n      />\n    )\n  }\n}\n\nfunction CatchBoundaryInner(props: {\n  children: any\n  errorComponent: any\n  errorState: { error: unknown; info: any }\n  reset: () => void\n}) {\n  const [activeErrorState, setActiveErrorState] = React.useState(\n    props.errorState,\n  )\n  const router = useRouterContext()\n  const errorComponent = props.errorComponent ?? ErrorComponent\n  const prevKeyRef = React.useRef('' as any)\n\n  React.useEffect(() => {\n    if (activeErrorState) {\n      if (router.state.currentLocation.key !== prevKeyRef.current) {\n        setActiveErrorState({} as any)\n      }\n    }\n\n    prevKeyRef.current = router.state.currentLocation.key\n  }, [activeErrorState, router.state.currentLocation.key])\n\n  React.useEffect(() => {\n    if (props.errorState.error) {\n      setActiveErrorState(props.errorState)\n    }\n    // props.reset()\n  }, [props.errorState.error])\n\n  if (props.errorState.error && activeErrorState.error) {\n    return React.createElement(errorComponent, activeErrorState)\n  }\n\n  return props.children\n}\n\nexport function ErrorComponent({ error }: { error: any }) {\n  return (\n    <div style={{ padding: '.5rem', maxWidth: '100%' }}>\n      <strong style={{ fontSize: '1.2rem' }}>Something went wrong!</strong>\n      <div style={{ height: '.5rem' }} />\n      <div>\n        <pre\n          style={{\n            fontSize: '.7em',\n            border: '1px solid red',\n            borderRadius: '.25rem',\n            padding: '.5rem',\n            color: 'red',\n            overflow: 'auto',\n          }}\n        >\n          {error.message ? <code>{error.message}</code> : null}\n        </pre>\n      </div>\n    </div>\n  )\n}\n\nexport function useBlocker(\n  message: string,\n  condition: boolean | any = true,\n): void {\n  const router = useRouter()\n\n  React.useEffect(() => {\n    if (!condition) return\n\n    let unblock = router.history.block((retry, cancel) => {\n      if (window.confirm(message)) {\n        unblock()\n        retry()\n      } else {\n        cancel()\n      }\n    })\n\n    return unblock\n  })\n}\n\nexport function Block({ message, condition, children }: PromptProps) {\n  useBlocker(message, condition)\n  return (children ?? null) as ReactNode\n}\n", "import { ParsePathParams } from './link'\nimport { RouteMatch } from './routeMatch'\nimport { AnyRouter, RegisteredRoutesInfo, Router } from './router'\nimport {\n  IsAny,\n  NoInfer,\n  PickRequired,\n  PickUnsafe,\n  UnionToIntersection,\n} from './utils'\nimport invariant from 'tiny-invariant'\nimport { joinPaths, trimPath, trimPathRight } from './path'\nimport { AnyRoutesInfo, DefaultRoutesInfo } from './routeInfo'\nimport {\n  MakeLinkOptions,\n  RouteComponent,\n  useLoader,\n  useMatch,\n  useSearch,\n} from './react'\n\nexport const rootRouteId = '__root__' as const\nexport type RootRouteId = typeof rootRouteId\nexport type AnyPathParams = {}\nexport type AnySearchSchema = {}\nexport type AnyContext = {}\nexport interface RouteMeta {}\nexport interface RouteContext {}\n\nexport type RouteOptionsBase<TCustomId, TPath> =\n  | {\n      path: TPath\n    }\n  | {\n      id: TCustomId\n    }\n\nexport type RouteOptionsBaseIntersection<TCustomId, TPath> =\n  UnionToIntersection<RouteOptionsBase<TCustomId, TPath>>\n\nexport type MetaOptions = keyof PickRequired<RouteMeta> extends never\n  ? {\n      meta?: RouteMeta\n    }\n  : {\n      meta: RouteMeta\n    }\n\ntype GetContextFn<\n  TParentRoute,\n  TAllParams,\n  TFullSearchSchema,\n  TParentContext,\n  TAllParentContext,\n  TRouteContext,\n> = (\n  opts: {\n    params: TAllParams\n    search: TFullSearchSchema\n  } & (TParentRoute extends undefined\n    ? {\n        context?: TAllParentContext\n        parentContext?: TParentContext\n      }\n    : {\n        context: TAllParentContext\n        parentContext: TParentContext\n      }),\n) => TRouteContext\n\nexport type ContextOptions<\n  TParentRoute,\n  TAllParams,\n  TFullSearchSchema,\n  TParentContext,\n  TAllParentContext,\n  TRouteContext,\n> = keyof PickRequired<RouteContext> extends never\n  ? {\n      getContext?: GetContextFn<\n        TParentRoute,\n        TAllParams,\n        TFullSearchSchema,\n        TParentContext,\n        TAllParentContext,\n        TRouteContext\n      >\n    }\n  : {\n      getContext: GetContextFn<\n        TParentRoute,\n        TAllParams,\n        TFullSearchSchema,\n        TParentContext,\n        TAllParentContext,\n        TRouteContext\n      >\n    }\n\nexport type RouteProps<\n  TParentRoute extends AnyRoute,\n  TPath extends string,\n  TFullPath extends ResolveFullPath<\n    TParentRoute,\n    TPath,\n    RoutePrefix<TParentRoute['fullPath'], TPath>\n  >,\n  TCustomId extends string,\n  TId extends ResolveId<TParentRoute, TCustomId, TPath>,\n  TLoader,\n  TSearchSchema extends AnySearchSchema,\n  TFullSearchSchema extends AnySearchSchema,\n  TAllParams,\n  TParentContext,\n  TAllParentContext extends IsAny<\n    TParentRoute['__types']['allParams'],\n    TParentContext,\n    TParentRoute['__types']['allParams'] & TParentContext\n  >,\n  TRouteContext,\n  TContext,\n  TRouterContext extends AnyContext,\n> = {\n  useMatch: () => RouteMatch<\n    AnyRoutesInfo,\n    Route<\n      TParentRoute,\n      TPath,\n      TFullPath,\n      TCustomId,\n      TId,\n      TLoader,\n      TSearchSchema,\n      TFullSearchSchema,\n      TParentContext,\n      TAllParentContext,\n      TRouteContext,\n      TContext,\n      TRouterContext,\n      any,\n      any\n    >\n  >\n  useLoader: () => TLoader\n  useSearch: <\n    TStrict extends boolean = true,\n    TSearch = TFullSearchSchema,\n    TSelected = TSearch,\n  >(opts?: {\n    strict?: TStrict\n    track?: (search: TSearch) => TSelected\n  }) => TStrict extends true ? TSelected : TSelected | undefined\n  useParams: <\n    TDefaultSelected = TAllParams,\n    TSelected = TDefaultSelected,\n  >(opts?: {\n    track?: (search: TDefaultSelected) => TSelected\n  }) => TSelected\n  useContext: () => TContext\n  // navigate: <T extends TFullPath, TTo extends string = ''>(\n  //   opts?: MakeLinkOptions<T, TTo>,\n  // ) => Promise<void>\n}\n\nexport type RouteOptions<\n  TParentRoute extends AnyRoute = AnyRoute,\n  TCustomId extends string = string,\n  TPath extends string = string,\n  TLoader = unknown,\n  TParentSearchSchema extends {} = {},\n  TSearchSchema extends AnySearchSchema = {},\n  TFullSearchSchema extends AnySearchSchema = TSearchSchema,\n  TParentParams extends AnyPathParams = {},\n  TParams = Record<ParsePathParams<TPath>, string>,\n  TAllParams = TParams,\n  TParentContext extends AnyContext = AnyContext,\n  TAllParentContext extends IsAny<\n    TParentRoute['__types']['allParams'],\n    TParentContext,\n    TParentRoute['__types']['allParams'] & TParentContext\n  > = IsAny<\n    TParentRoute['__types']['allParams'],\n    TParentContext,\n    TParentRoute['__types']['allParams'] & TParentContext\n  >,\n  TRouteContext extends RouteContext = RouteContext,\n  TContext extends MergeFromParent<\n    TAllParentContext,\n    TRouteContext\n  > = MergeFromParent<TAllParentContext, TRouteContext>,\n> = RouteOptionsBase<TCustomId, TPath> & {\n  getParentRoute: () => TParentRoute\n  // If true, this route will be matched as case-sensitive\n  caseSensitive?: boolean\n  // Filter functions that can manipulate search params *before* they are passed to links and navigate\n  // calls that match this route.\n  preSearchFilters?: SearchFilter<TFullSearchSchema>[]\n  // Filter functions that can manipulate search params *after* they are passed to links and navigate\n  // calls that match this route.\n  postSearchFilters?: SearchFilter<TFullSearchSchema>[]\n  // The content to be rendered when the route is matched. If no component is provided, defaults to `<Outlet />`\n  component?: RouteComponent<\n    RouteProps<\n      TParentRoute,\n      TPath,\n      ResolveFullPath<TParentRoute, TPath>,\n      TCustomId,\n      ResolveId<TParentRoute, TCustomId, TPath>,\n      TLoader,\n      TSearchSchema,\n      TFullSearchSchema,\n      TAllParams,\n      TParentContext,\n      TAllParentContext,\n      TRouteContext,\n      TContext,\n      NoInfer<TRouteContext>\n    >\n  > //\n  // The content to be rendered when the route encounters an error\n  errorComponent?: RouteComponent<{\n    error: Error\n    info: { componentStack: string }\n  }> //\n  // If supported by your framework, the content to be rendered as the fallback content until the route is ready to render\n  pendingComponent?: RouteComponent<\n    RouteProps<\n      TParentRoute,\n      TPath,\n      ResolveFullPath<TParentRoute, TPath>,\n      TCustomId,\n      ResolveId<TParentRoute, TCustomId, TPath>,\n      TLoader,\n      TSearchSchema,\n      TFullSearchSchema,\n      TAllParams,\n      TParentContext,\n      TAllParentContext,\n      TRouteContext,\n      TContext,\n      NoInfer<TRouteContext>\n    >\n  > //\n  wrapInSuspense?: boolean\n\n  // This async function is called before a route is loaded.\n  // If an error is thrown here, the route's loader will not be called.\n  // If thrown during a navigation, the navigation will be cancelled and the error will be passed to the `onLoadError` function.\n  // If thrown during a preload event, the error will be logged to the console.\n  beforeLoad?: (opts: {\n    router: AnyRouter\n    match: RouteMatch\n  }) => Promise<void> | void\n  // This function will be called if the route's loader throws an error **during an attempted navigation**.\n  // If you want to redirect due to an error, call `router.navigate()` from within this function.\n  onBeforeLoadError?: (err: any) => void\n  validateSearch?: SearchSchemaValidator<TSearchSchema, TParentSearchSchema>\n  // This function will be called if the route's validateSearch option throws an error **during an attempted validation**.\n  // If you want to redirect due to an error, call `router.navigate()` from within this function.\n  // If you want to display the errorComponent, rethrow the error\n  onValidateSearchError?: (err: any) => void\n  // An asynchronous function responsible for preparing or fetching data for the route before it is rendered\n  loader?: OnLoadFn<\n    TLoader,\n    TSearchSchema,\n    TFullSearchSchema,\n    TAllParams,\n    NoInfer<TRouteContext>,\n    TContext\n  >\n  onLoadError?: (err: any) => void\n  onError?: (err: any) => void\n  // This function is called\n  // when moving from an inactive state to an active one. Likewise, when moving from\n  // an active to an inactive state, the return function (if provided) is called.\n  onLoaded?: (matchContext: {\n    params: TAllParams\n    search: TFullSearchSchema\n  }) =>\n    | void\n    | undefined\n    | ((match: { params: TAllParams; search: TFullSearchSchema }) => void)\n  // This function is called when the route remains active from one transition to the next.\n  onTransition?: (match: {\n    params: TAllParams\n    search: TFullSearchSchema\n  }) => void\n} & MetaOptions &\n  ContextOptions<\n    TParentRoute,\n    TAllParams,\n    TFullSearchSchema,\n    TParentContext,\n    TAllParentContext,\n    TRouteContext\n  > &\n  (\n    | {\n        // Parse params optionally receives path params as strings and returns them in a parsed format (like a number or boolean)\n        parseParams?: (\n          rawParams: IsAny<TPath, any, Record<ParsePathParams<TPath>, string>>,\n        ) => TParams extends Record<ParsePathParams<TPath>, any>\n          ? TParams\n          : 'parseParams must return an object'\n        stringifyParams?: (\n          params: NoInfer<TParams>,\n        ) => Record<ParsePathParams<TPath>, string>\n      }\n    | {\n        stringifyParams?: never\n        parseParams?: never\n      }\n  ) &\n  (PickUnsafe<TParentParams, ParsePathParams<TPath>> extends never // Detect if an existing path param is being redefined\n    ? { test?: PickUnsafe<TParentParams, ParsePathParams<TPath>> }\n    : 'Cannot redefined path params in child routes!')\n\n// The parse type here allows a zod schema to be passed directly to the validator\nexport type SearchSchemaValidator<TReturn, TParentSchema> =\n  | SearchSchemaValidatorObj<TReturn, TParentSchema>\n  | SearchSchemaValidatorFn<TReturn, TParentSchema>\n\nexport type SearchSchemaValidatorObj<TReturn, TParentSchema> = {\n  parse?: SearchSchemaValidatorFn<TReturn, TParentSchema>\n}\n\nexport type SearchSchemaValidatorFn<TReturn, TParentSchema> = (\n  searchObj: Record<string, unknown>,\n) => {} extends TParentSchema\n  ? TReturn\n  : keyof TReturn extends keyof TParentSchema\n  ? {\n      error: 'Top level search params cannot be redefined by child routes!'\n      keys: keyof TReturn & keyof TParentSchema\n    }\n  : TReturn\n\nexport type DefinedPathParamWarning =\n  'Path params cannot be redefined by child routes!'\n\nexport type ParentParams<TParentParams> = AnyPathParams extends TParentParams\n  ? {}\n  : {\n      [Key in keyof TParentParams]?: DefinedPathParamWarning\n    }\n\nexport type OnLoadFn<\n  TLoader = unknown,\n  TSearchSchema extends AnySearchSchema = {},\n  TFullSearchSchema extends AnySearchSchema = {},\n  TAllParams = {},\n  TContext extends AnyContext = AnyContext,\n  TAllContext extends AnyContext = AnyContext,\n> = (\n  loaderContext: LoaderContext<\n    TSearchSchema,\n    TFullSearchSchema,\n    TAllParams,\n    TContext,\n    TAllContext\n  >,\n) => Promise<TLoader> | TLoader\n\nexport interface LoaderContext<\n  TSearchSchema extends AnySearchSchema = {},\n  TFullSearchSchema extends AnySearchSchema = {},\n  TAllParams = {},\n  TContext extends AnyContext = AnyContext,\n  TAllContext extends AnyContext = AnyContext,\n> {\n  params: TAllParams\n  routeSearch: TSearchSchema\n  search: TFullSearchSchema\n  signal?: AbortSignal\n  preload: boolean\n  routeContext: TContext\n  context: TAllContext\n}\n\nexport type UnloaderFn<TPath extends string> = (\n  routeMatch: RouteMatch<any, Route>,\n) => void\n\nexport type SearchFilter<T, U = T> = (prev: T) => U\n\ntype ResolveId<\n  TParentRoute,\n  TCustomId extends string,\n  TPath extends string,\n> = TParentRoute extends { id: infer TParentId extends string }\n  ? RoutePrefix<TParentId, string extends TCustomId ? TPath : TCustomId>\n  : RootRouteId\n\nexport type InferFullSearchSchema<TRoute> = TRoute extends {\n  isRoot: true\n  __types: {\n    searchSchema: infer TSearchSchema\n  }\n}\n  ? TSearchSchema\n  : TRoute extends {\n      __types: {\n        fullSearchSchema: infer TFullSearchSchema\n      }\n    }\n  ? TFullSearchSchema\n  : {}\n\nexport type ResolveFullSearchSchema<TParentRoute, TSearchSchema> =\n  InferFullSearchSchema<TParentRoute> & TSearchSchema\n\nexport interface AnyRoute\n  extends Route<\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any\n  > {}\n\ntype MergeFromParent<T, U> = IsAny<T, U, T & U>\n\nexport class Route<\n  TParentRoute extends AnyRoute = AnyRoute,\n  TPath extends string = string,\n  TFullPath extends ResolveFullPath<TParentRoute, TPath> = ResolveFullPath<\n    TParentRoute,\n    TPath\n  >,\n  TCustomId extends string = string,\n  TId extends ResolveId<TParentRoute, TCustomId, TPath> = ResolveId<\n    TParentRoute,\n    TCustomId,\n    TPath\n  >,\n  TLoader = unknown,\n  TSearchSchema extends AnySearchSchema = {},\n  TFullSearchSchema extends AnySearchSchema = ResolveFullSearchSchema<\n    TParentRoute,\n    TSearchSchema\n  >,\n  TParams extends Record<ParsePathParams<TPath>, any> = Record<\n    ParsePathParams<TPath>,\n    string\n  >,\n  TAllParams extends MergeFromParent<\n    TParentRoute['__types']['allParams'],\n    TParams\n  > = MergeFromParent<TParentRoute['__types']['allParams'], TParams>,\n  TParentContext extends TParentRoute['__types']['routeContext'] = TParentRoute['__types']['routeContext'],\n  TAllParentContext extends TParentRoute['__types']['context'] = TParentRoute['__types']['context'],\n  TRouteContext extends RouteContext = RouteContext,\n  TContext extends MergeFromParent<\n    TParentRoute['__types']['context'],\n    TRouteContext\n  > = MergeFromParent<TParentRoute['__types']['context'], TRouteContext>,\n  TRouterContext extends AnyContext = AnyContext,\n  TChildren extends unknown = unknown,\n  TRoutesInfo extends DefaultRoutesInfo = DefaultRoutesInfo,\n> {\n  __types!: {\n    parentRoute: TParentRoute\n    path: TPath\n    fullPath: TFullPath\n    customId: TCustomId\n    id: TId\n    loader: TLoader\n    searchSchema: TSearchSchema\n    fullSearchSchema: TFullSearchSchema\n    params: TParams\n    allParams: TAllParams\n    parentContext: TParentContext\n    allParentContext: TAllParentContext\n    routeContext: TRouteContext\n    context: TContext\n    children: TChildren\n    routesInfo: TRoutesInfo\n    routerContext: TRouterContext\n  }\n  isRoot: TParentRoute extends Route<any> ? true : false\n  options: RouteOptions<\n    TParentRoute,\n    TCustomId,\n    TPath,\n    TLoader,\n    InferFullSearchSchema<TParentRoute>,\n    TSearchSchema,\n    InferFullSearchSchema<TParentRoute> & TSearchSchema,\n    TParentRoute['__types']['allParams'],\n    TParams,\n    TAllParams,\n    TParentContext,\n    TAllParentContext,\n    TRouteContext,\n    TContext\n  >\n\n  // Set up in this.init()\n  parentRoute!: TParentRoute\n  id!: TId\n  // customId!: TCustomId\n  path!: TPath\n  fullPath!: TFullPath\n\n  // Optional\n  children?: TChildren\n  originalIndex?: number\n  router?: Router<TRoutesInfo['routeTree'], TRoutesInfo>\n\n  constructor(\n    options: RouteOptions<\n      TParentRoute,\n      TCustomId,\n      TPath,\n      TLoader,\n      InferFullSearchSchema<TParentRoute>,\n      TSearchSchema,\n      TFullSearchSchema,\n      TParentRoute['__types']['allParams'],\n      TParams,\n      TAllParams,\n      TParentContext,\n      TAllParentContext,\n      TRouteContext,\n      TContext\n    >,\n  ) {\n    this.options = (options as any) || {}\n    this.isRoot = !options?.getParentRoute as any\n  }\n\n  init = (opts: { originalIndex: number; router: AnyRouter }) => {\n    this.originalIndex = opts.originalIndex\n    this.router = opts.router\n\n    const allOptions = this.options as RouteOptions<\n      TParentRoute,\n      TCustomId,\n      TPath,\n      TLoader,\n      InferFullSearchSchema<TParentRoute>,\n      TSearchSchema,\n      TFullSearchSchema,\n      TParentRoute['__types']['allParams'],\n      TParams,\n      TAllParams,\n      TParentContext,\n      TAllParentContext,\n      TRouteContext,\n      TContext\n    > &\n      RouteOptionsBaseIntersection<TCustomId, TPath>\n\n    const isRoot = !allOptions?.path && !allOptions?.id\n\n    this.parentRoute = this.options?.getParentRoute?.()\n\n    if (isRoot) {\n      this.path = rootRouteId as TPath\n    } else {\n      invariant(\n        this.parentRoute,\n        `Child Route instances must pass a 'getParentRoute: () => ParentRoute' option that returns a Route instance.`,\n      )\n    }\n\n    let path: undefined | string = isRoot ? rootRouteId : allOptions.path\n\n    // If the path is anything other than an index path, trim it up\n    if (path && path !== '/') {\n      path = trimPath(path)\n    }\n\n    const customId = allOptions?.id || path\n\n    // Strip the parentId prefix from the first level of children\n    let id = isRoot\n      ? rootRouteId\n      : joinPaths([\n          (this.parentRoute.id as any) === rootRouteId\n            ? ''\n            : this.parentRoute.id,\n          customId,\n        ])\n\n    if (path === rootRouteId) {\n      path = '/'\n    }\n\n    if (id !== rootRouteId) {\n      id = joinPaths(['/', id])\n    }\n\n    const fullPath =\n      id === rootRouteId\n        ? '/'\n        : trimPathRight(joinPaths([this.parentRoute.fullPath, path]))\n\n    this.path = path as TPath\n    this.id = id as TId\n    // this.customId = customId as TCustomId\n    this.fullPath = fullPath as TFullPath\n  }\n\n  addChildren = <TNewChildren extends AnyRoute[]>(\n    children: TNewChildren,\n  ): Route<\n    TParentRoute,\n    TPath,\n    TFullPath,\n    TCustomId,\n    TId,\n    TLoader,\n    TSearchSchema,\n    TFullSearchSchema,\n    TParams,\n    TAllParams,\n    TParentContext,\n    TAllParentContext,\n    TRouteContext,\n    TContext,\n    TRouterContext,\n    TNewChildren,\n    TRoutesInfo\n  > => {\n    this.children = children as any\n    return this as any\n  }\n\n  useMatch = <TStrict extends boolean = true, TSelected = TContext>(opts?: {\n    strict?: TStrict\n    track?: (search: TContext) => TSelected\n  }): TStrict extends true ? TSelected : TSelected | undefined => {\n    return useMatch({ ...opts, from: this.id }) as any\n  }\n\n  useLoader = <TStrict extends boolean = true, TSelected = TLoader>(opts?: {\n    strict?: TStrict\n    track?: (search: TLoader) => TSelected\n  }): TStrict extends true ? TSelected : TSelected | undefined => {\n    return useLoader({ ...opts, from: this.id }) as any\n  }\n\n  useContext = <TStrict extends boolean = true, TSelected = TContext>(opts?: {\n    strict?: TStrict\n    track?: (search: TContext) => TSelected\n  }): TStrict extends true ? TSelected : TSelected | undefined => {\n    return useMatch({ ...opts, from: this.id }).context\n  }\n\n  useSearch = <\n    TStrict extends boolean = true,\n    TSelected = TFullSearchSchema,\n  >(opts?: {\n    strict?: TStrict\n    track?: (search: TFullSearchSchema) => TSelected\n  }): TStrict extends true ? TSelected : TSelected | undefined => {\n    return useSearch({ ...opts, from: this.id })\n  }\n}\n\nexport type AnyRootRoute = RootRoute<any, any, any, any>\n\nexport class RootRoute<\n  TLoader = unknown,\n  TSearchSchema extends AnySearchSchema = {},\n  TContext extends RouteContext = RouteContext,\n  TRouterContext extends {} = {},\n> extends Route<\n  any,\n  '/',\n  '/',\n  string,\n  RootRouteId,\n  TLoader,\n  TSearchSchema,\n  TSearchSchema,\n  {},\n  {},\n  TRouterContext,\n  TRouterContext,\n  MergeFromParent<TRouterContext, TContext>,\n  MergeFromParent<TRouterContext, TContext>,\n  TRouterContext,\n  any,\n  any\n> {\n  constructor(\n    options?: Omit<\n      RouteOptions<\n        AnyRoute,\n        RootRouteId,\n        '',\n        TLoader,\n        {},\n        TSearchSchema,\n        NoInfer<TSearchSchema>,\n        {},\n        TRouterContext,\n        TRouterContext,\n        TContext,\n        NoInfer<TContext>\n      >,\n      | 'path'\n      | 'id'\n      | 'getParentRoute'\n      | 'caseSensitive'\n      | 'parseParams'\n      | 'stringifyParams'\n    >,\n  ) {\n    super(options as any)\n  }\n\n  static withRouterContext = <TRouterContext extends {}>() => {\n    return <\n      TLoader = unknown,\n      TSearchSchema extends AnySearchSchema = {},\n      TContext extends {} = {},\n    >(\n      options?: Omit<\n        RouteOptions<\n          AnyRoute,\n          RootRouteId,\n          '',\n          TLoader,\n          {},\n          TSearchSchema,\n          NoInfer<TSearchSchema>,\n          {},\n          TRouterContext,\n          TRouterContext,\n          TContext,\n          TRouterContext & TContext\n        >,\n        'path' | 'id' | 'getParentRoute' | 'caseSensitive'\n      >,\n    ) =>\n      new RootRoute<TLoader, TSearchSchema, TContext, TRouterContext>(\n        options as any,\n      )\n  }\n}\n\ntype ResolveFullPath<\n  TParentRoute extends AnyRoute,\n  TPath extends string,\n  TPrefixed extends RoutePrefix<TParentRoute['fullPath'], TPath> = RoutePrefix<\n    TParentRoute['fullPath'],\n    TPath\n  >,\n> = TPrefixed extends RootRouteId ? '/' : TrimPathRight<`${TPrefixed}`>\n\ntype RoutePrefix<\n  TPrefix extends string,\n  TId extends string,\n> = string extends TId\n  ? RootRouteId\n  : TId extends string\n  ? TPrefix extends RootRouteId\n    ? TId extends '/'\n      ? '/'\n      : `/${TrimPath<TId>}`\n    : `${TPrefix}/${TId}` extends '/'\n    ? '/'\n    : `/${TrimPathLeft<`${TrimPathRight<TPrefix>}/${TrimPath<TId>}`>}`\n  : never\n\ntype TrimPath<T extends string> = '' extends T\n  ? ''\n  : TrimPathRight<TrimPathLeft<T>>\n\ntype TrimPathLeft<T extends string> = T extends `${RootRouteId}/${infer U}`\n  ? TrimPathLeft<U>\n  : T extends `/${infer U}`\n  ? TrimPathLeft<U>\n  : T\ntype TrimPathRight<T extends string> = T extends '/'\n  ? '/'\n  : T extends `${infer U}/`\n  ? TrimPathRight<U>\n  : T\n\n// const rootRoute = new RootRoute({\n//   validateSearch: () => null as unknown as { root?: boolean },\n// })\n\n// const aRoute = new Route({\n//   getParentRoute: () => rootRoute,\n//   path: 'a',\n//   validateSearch: () => null as unknown as { a?: string },\n// })\n\n// const bRoute = new Route({\n//   getParentRoute: () => aRoute,\n//   path: 'b',\n// })\n\n// const rootIsRoot = rootRoute.isRoot\n// //    ^?\n// const aIsRoot = aRoute.isRoot\n// //    ^?\n\n// const rId = rootRoute.id\n// //    ^?\n// const aId = aRoute.id\n// //    ^?\n// const bId = bRoute.id\n// //    ^?\n\n// const rPath = rootRoute.fullPath\n// //    ^?\n// const aPath = aRoute.fullPath\n// //    ^?\n// const bPath = bRoute.fullPath\n// //    ^?\n\n// const rSearch = rootRoute.__types.fullSearchSchema\n// //    ^?\n// const aSearch = aRoute.__types.fullSearchSchema\n// //    ^?\n// const bSearch = bRoute.__types.fullSearchSchema\n// //    ^?\n\n// const config = rootRoute.addChildren([aRoute.addChildren([bRoute])])\n// //    ^?\n", "import { decode, encode } from './qss'\nimport { AnySearchSchema } from './route'\n\nexport const defaultParseSearch = parseSearchWith(JSON.parse)\nexport const defaultStringifySearch = stringifySearchWith(JSON.stringify)\n\nexport function parseSearchWith(parser: (str: string) => any) {\n  return (searchStr: string): AnySearchSchema => {\n    if (searchStr.substring(0, 1) === '?') {\n      searchStr = searchStr.substring(1)\n    }\n\n    let query: Record<string, unknown> = decode(searchStr)\n\n    // Try to parse any query params that might be json\n    for (let key in query) {\n      const value = query[key]\n      if (typeof value === 'string') {\n        try {\n          query[key] = parser(value)\n        } catch (err) {\n          //\n        }\n      }\n    }\n\n    return query\n  }\n}\n\nexport function stringifySearchWith(stringify: (search: any) => string) {\n  return (search: Record<string, any>) => {\n    search = { ...search }\n\n    if (search) {\n      Object.keys(search).forEach((key) => {\n        const val = search[key]\n        if (typeof val === 'undefined' || val === undefined) {\n          delete search[key]\n        } else if (val && typeof val === 'object' && val !== null) {\n          try {\n            search[key] = stringify(val)\n          } catch (err) {\n            // silent\n          }\n        }\n      })\n    }\n\n    const searchStr = encode(search as Record<string, string>).toString()\n\n    return searchStr ? `?${searchStr}` : ''\n  }\n}\n", "import { Store } from '@tanstack/react-store'\nimport invariant from 'tiny-invariant'\n\n//\n\nimport {\n  LinkInfo,\n  LinkOptions,\n  NavigateOptions,\n  ToOptions,\n  ValidFromPath,\n  ResolveRelativePath,\n} from './link'\nimport {\n  cleanPath,\n  interpolatePath,\n  joinPaths,\n  matchPathname,\n  parsePathname,\n  resolvePath,\n  trimPath,\n  trimPathLeft,\n} from './path'\nimport {\n  Route,\n  AnySearchSchema,\n  AnyRoute,\n  RootRoute,\n  AnyContext,\n  AnyRootRoute,\n} from './route'\nimport { RoutesInfo, AnyRoutesInfo, RoutesById } from './routeInfo'\nimport { AnyRouteMatch, RouteMatch, RouteMatchState } from './routeMatch'\nimport { defaultParseSearch, defaultStringifySearch } from './searchParams'\nimport {\n  functionalUpdate,\n  last,\n  NoInfer,\n  pick,\n  PickAsRequired,\n  Timeout,\n  Updater,\n  replaceEqualDeep,\n  partialDeepEqual,\n} from './utils'\nimport {\n  createBrowserHistory,\n  createMemoryHistory,\n  RouterHistory,\n} from './history'\nimport { RouteComponent } from './react'\n\n//\n\ndeclare global {\n  interface Window {\n    __DEHYDRATED__?: Record<string, any>\n  }\n}\n\nexport interface Register {\n  // router: Router\n}\n\nexport type AnyRouter = Router<any, any, any>\n\nexport type RegisteredRouter = Register extends {\n  router: Router<infer TRoute, infer TRoutesInfo>\n}\n  ? Router<TRoute, TRoutesInfo>\n  : Router\n\nexport type RegisteredRoutesInfo = Register extends {\n  router: Router<infer TRoute, infer TRoutesInfo>\n}\n  ? TRoutesInfo\n  : AnyRoutesInfo\n\nexport interface LocationState {}\n\nexport interface ParsedLocation<\n  TSearchObj extends AnySearchSchema = {},\n  TState extends LocationState = LocationState,\n> {\n  href: string\n  pathname: string\n  search: TSearchObj\n  searchStr: string\n  state: TState\n  hash: string\n  key?: string\n}\n\nexport interface FromLocation {\n  pathname: string\n  search?: unknown\n  key?: string\n  hash?: string\n}\n\nexport type SearchSerializer = (searchObj: Record<string, any>) => string\nexport type SearchParser = (searchStr: string) => Record<string, any>\nexport type FilterRoutesFn = <TRoute extends AnyRoute>(\n  routes: TRoute[],\n) => TRoute[]\n\ntype RouterContextOptions<TRouteTree extends AnyRoute> =\n  AnyContext extends TRouteTree['__types']['routerContext']\n    ? {\n        context?: TRouteTree['__types']['routerContext']\n      }\n    : {\n        context: TRouteTree['__types']['routerContext']\n      }\n\nexport interface RouterOptions<\n  TRouteTree extends AnyRoute,\n  TDehydrated extends Record<string, any>,\n> {\n  history?: RouterHistory\n  stringifySearch?: SearchSerializer\n  parseSearch?: SearchParser\n  filterRoutes?: FilterRoutesFn\n  defaultPreload?: false | 'intent'\n  defaultPreloadDelay?: number\n  defaultComponent?: RouteComponent\n  defaultErrorComponent?: RouteComponent<{\n    error: Error\n    info: { componentStack: string }\n  }>\n  defaultPendingComponent?: RouteComponent\n  defaultLoaderMaxAge?: number\n  defaultLoaderGcMaxAge?: number\n  caseSensitive?: boolean\n  routeTree?: TRouteTree\n  basepath?: string\n  createRoute?: (opts: { route: AnyRoute; router: AnyRouter }) => void\n  onRouteChange?: () => void\n  fetchServerDataFn?: FetchServerDataFn\n  context?: TRouteTree['__types']['routerContext']\n  Provider?: React.ComponentType<{ children: any }>\n  dehydrate?: () => TDehydrated\n  hydrate?: (dehydrated: TDehydrated) => void\n}\n\ntype FetchServerDataFn = (ctx: {\n  router: AnyRouter\n  routeMatch: RouteMatch\n}) => Promise<any>\n\nexport interface RouterState<\n  TRoutesInfo extends AnyRoutesInfo = AnyRoutesInfo,\n  TState extends LocationState = LocationState,\n> {\n  status: 'idle' | 'pending'\n  latestLocation: ParsedLocation<TRoutesInfo['fullSearchSchema'], TState>\n  currentMatches: RouteMatch<TRoutesInfo, TRoutesInfo['routeIntersection']>[]\n  currentLocation: ParsedLocation<TRoutesInfo['fullSearchSchema'], TState>\n  pendingMatches?: RouteMatch<TRoutesInfo, TRoutesInfo['routeIntersection']>[]\n  pendingLocation?: ParsedLocation<TRoutesInfo['fullSearchSchema'], TState>\n  lastUpdated: number\n}\n\nexport type ListenerFn = () => void\n\nexport interface BuildNextOptions {\n  to?: string | number | null\n  params?: true | Updater<unknown>\n  search?: true | Updater<unknown>\n  hash?: true | Updater<string>\n  state?: LocationState\n  key?: string\n  from?: string\n  fromCurrent?: boolean\n  __matches?: RouteMatch[]\n}\n\nexport type MatchCacheEntry = {\n  gc: number\n  match: RouteMatch\n}\n\nexport interface MatchLocation {\n  to?: string | number | null\n  fuzzy?: boolean\n  caseSensitive?: boolean\n  from?: string\n  fromCurrent?: boolean\n}\n\nexport interface MatchRouteOptions {\n  pending?: boolean\n  caseSensitive?: boolean\n  includeSearch?: boolean\n  fuzzy?: boolean\n}\n\ntype LinkCurrentTargetElement = {\n  preloadTimeout?: null | ReturnType<typeof setTimeout>\n}\n\nexport interface DehydratedRouterState\n  extends Pick<\n    RouterState,\n    'status' | 'latestLocation' | 'currentLocation' | 'lastUpdated'\n  > {\n  // currentMatches: DehydratedRouteMatch[]\n}\n\nexport interface DehydratedRouter {\n  state: DehydratedRouterState\n}\n\nexport type MatchCache = Record<string, MatchCacheEntry>\n\ninterface DehydratedRouteMatch {\n  id: string\n  state: Pick<RouteMatchState<any, any>, 'status'>\n}\n\nexport const defaultFetchServerDataFn: FetchServerDataFn = async ({\n  router,\n  routeMatch,\n}) => {\n  const next = router.buildNext({\n    to: '.',\n    search: (d: any) => ({\n      ...(d ?? {}),\n      __data: {\n        matchId: routeMatch.id,\n      },\n    }),\n  })\n\n  const res = await fetch(next.href, {\n    method: 'GET',\n    signal: routeMatch.abortController.signal,\n  })\n\n  if (res.ok) {\n    return res.json()\n  }\n\n  throw new Error('Failed to fetch match data')\n}\n\nexport type RouterConstructorOptions<\n  TRouteTree extends AnyRoute,\n  TDehydrated extends Record<string, any>,\n> = Omit<RouterOptions<TRouteTree, TDehydrated>, 'context'> &\n  RouterContextOptions<TRouteTree>\n\nexport class Router<\n  TRouteTree extends AnyRoute = AnyRoute,\n  TRoutesInfo extends AnyRoutesInfo = RoutesInfo<TRouteTree>,\n  TDehydrated extends Record<string, any> = Record<string, any>,\n> {\n  types!: {\n    // Super secret internal stuff\n    RootRoute: TRouteTree\n    RoutesInfo: TRoutesInfo\n  }\n\n  options: PickAsRequired<\n    RouterOptions<TRouteTree, TDehydrated>,\n    'stringifySearch' | 'parseSearch' | 'context'\n  >\n  context!: NonNullable<TRouteTree['__types']['routerContext']>\n  history!: RouterHistory\n  #unsubHistory?: () => void\n  basepath!: string\n  // __location: Location<TRoutesInfo['fullSearchSchema']>\n  routeTree!: RootRoute\n  routesById!: RoutesById<TRoutesInfo>\n  navigateTimeout: undefined | Timeout\n  nextAction: undefined | 'push' | 'replace'\n  navigationPromise: undefined | Promise<void>\n\n  __store: Store<RouterState<TRoutesInfo>>\n  state: RouterState<TRoutesInfo>\n  startedLoadingAt = Date.now()\n  resolveNavigation: () => void = () => {}\n\n  constructor(options?: RouterConstructorOptions<TRouteTree, TDehydrated>) {\n    this.options = {\n      defaultPreloadDelay: 50,\n      context: undefined!,\n      ...options,\n      stringifySearch: options?.stringifySearch ?? defaultStringifySearch,\n      parseSearch: options?.parseSearch ?? defaultParseSearch,\n      fetchServerDataFn: options?.fetchServerDataFn ?? defaultFetchServerDataFn,\n    }\n\n    this.__store = new Store<RouterState<TRoutesInfo>>(\n      getInitialRouterState(),\n      {\n        onUpdate: (state) => {\n          this.state = state\n        },\n      },\n    )\n    this.state = this.__store.state\n\n    this.update(options)\n\n    const next = this.buildNext({\n      hash: true,\n      fromCurrent: true,\n      search: true,\n      state: true,\n    })\n\n    if (this.state.latestLocation.href !== next.href) {\n      this.#commitLocation({ ...next, replace: true })\n    }\n  }\n\n  reset = () => {\n    this.__store.setState((s) => Object.assign(s, getInitialRouterState()))\n  }\n\n  mount = () => {\n    // Mount only does anything on the client\n    if (!isServer) {\n      // If the router matches are empty, start loading the matches\n      if (!this.state.currentMatches.length) {\n        this.safeLoad()\n      }\n    }\n\n    return () => {}\n  }\n\n  hydrate = async (__do_not_use_server_ctx?: any) => {\n    let ctx = __do_not_use_server_ctx\n    // Client hydrates from window\n    if (typeof document !== 'undefined') {\n      ctx = window.__DEHYDRATED__\n\n      invariant(\n        ctx,\n        'Expected to find a __DEHYDRATED__ property on window... but we did not. THIS IS VERY BAD',\n      )\n    }\n\n    this.options.hydrate?.(ctx)\n\n    return await this.load()\n  }\n\n  update = (opts?: RouterOptions<any, any>): this => {\n    Object.assign(this.options, opts)\n\n    this.context = this.options.context\n\n    if (\n      !this.history ||\n      (this.options.history && this.options.history !== this.history)\n    ) {\n      if (this.#unsubHistory) {\n        this.#unsubHistory()\n      }\n\n      this.history =\n        this.options.history ??\n        (isServer ? createMemoryHistory() : createBrowserHistory()!)\n\n      const parsedLocation = this.#parseLocation()\n\n      this.__store.setState((s) => ({\n        ...s,\n        latestLocation: parsedLocation,\n        currentLocation: parsedLocation,\n      }))\n\n      this.#unsubHistory = this.history.listen(() => {\n        this.safeLoad({\n          next: this.#parseLocation(this.state.latestLocation),\n        })\n      })\n    }\n\n    const { basepath, routeTree } = this.options\n\n    this.basepath = `/${trimPath(basepath ?? '') ?? ''}`\n\n    if (routeTree) {\n      this.routesById = {} as any\n      this.routeTree = this.#buildRouteTree(routeTree) as RootRoute\n    }\n\n    return this\n  }\n\n  buildNext = (opts: BuildNextOptions): ParsedLocation => {\n    const next = this.#buildLocation(opts)\n\n    const __matches = this.matchRoutes(next.pathname)\n\n    return this.#buildLocation({\n      ...opts,\n      __matches,\n    })\n  }\n\n  cancelMatches = () => {\n    ;[\n      ...this.state.currentMatches,\n      ...(this.state.pendingMatches || []),\n    ].forEach((match) => {\n      match.cancel()\n    })\n  }\n\n  safeLoad = (opts?: { next?: ParsedLocation }) => {\n    this.load(opts).catch((err) => {\n      console.warn(err)\n      invariant(false, 'Encountered an error during router.load()! ☝️.')\n    })\n  }\n\n  load = async (opts?: { next?: ParsedLocation }): Promise<void> => {\n    let now = Date.now()\n    const startedAt = now\n    this.startedLoadingAt = startedAt\n\n    // Cancel any pending matches\n    this.cancelMatches()\n\n    let matches!: RouteMatch<any, any>[]\n\n    this.__store.batch(() => {\n      if (opts?.next) {\n        // Ingest the new location\n        this.__store.setState((s) => ({\n          ...s,\n          latestLocation: opts.next!,\n        }))\n      }\n\n      // Match the routes\n      matches = this.matchRoutes(this.state.latestLocation.pathname, {\n        strictParseParams: true,\n      })\n\n      this.__store.setState((s) => ({\n        ...s,\n        status: 'pending',\n        pendingMatches: matches,\n        pendingLocation: this.state.latestLocation,\n      }))\n    })\n\n    // Load the matches\n    await this.loadMatches(\n      matches,\n      this.state.pendingLocation!,\n      // opts\n    )\n\n    if (this.startedLoadingAt !== startedAt) {\n      // Ignore side-effects of outdated side-effects\n      return this.navigationPromise\n    }\n\n    const previousMatches = this.state.currentMatches\n\n    const exiting: AnyRouteMatch[] = [],\n      staying: AnyRouteMatch[] = []\n\n    previousMatches.forEach((d) => {\n      if (matches.find((dd) => dd.id === d.id)) {\n        staying.push(d)\n      } else {\n        exiting.push(d)\n      }\n    })\n\n    const entering = matches.filter((d) => {\n      return !previousMatches.find((dd) => dd.id === d.id)\n    })\n\n    now = Date.now()\n\n    exiting.forEach((d) => {\n      d.__onExit?.({\n        params: d.params,\n        search: d.state.routeSearch,\n      })\n\n      // Clear non-loading error states when match leaves\n      if (d.state.status === 'error') {\n        this.__store.setState((s) => ({\n          ...s,\n          status: 'idle',\n          error: undefined,\n        }))\n      }\n    })\n\n    staying.forEach((d) => {\n      d.route.options.onTransition?.({\n        params: d.params,\n        search: d.state.routeSearch,\n      })\n    })\n\n    entering.forEach((d) => {\n      d.__onExit = d.route.options.onLoaded?.({\n        params: d.params,\n        search: d.state.search,\n      })\n    })\n\n    const prevLocation = this.state.currentLocation\n\n    this.__store.setState((s) => ({\n      ...s,\n      status: 'idle',\n      currentLocation: this.state.latestLocation,\n      currentMatches: matches,\n      pendingLocation: undefined,\n      pendingMatches: undefined,\n    }))\n\n    matches.forEach((match) => {\n      match.__commit()\n    })\n\n    if (prevLocation!.href !== this.state.currentLocation.href) {\n      this.options.onRouteChange?.()\n    }\n\n    this.resolveNavigation()\n  }\n\n  getRoute = <TId extends keyof TRoutesInfo['routesById']>(\n    id: TId,\n  ): TRoutesInfo['routesById'][TId] => {\n    const route = this.routesById[id]\n\n    invariant(route, `Route with id \"${id as string}\" not found`)\n\n    return route\n  }\n\n  loadRoute = async (\n    navigateOpts: BuildNextOptions = this.state.latestLocation,\n  ): Promise<RouteMatch[]> => {\n    const next = this.buildNext(navigateOpts)\n    const matches = this.matchRoutes(next.pathname, {\n      strictParseParams: true,\n    })\n    await this.loadMatches(matches, next)\n    return matches\n  }\n\n  preloadRoute = async (\n    navigateOpts: BuildNextOptions = this.state.latestLocation,\n  ) => {\n    const next = this.buildNext(navigateOpts)\n    const matches = this.matchRoutes(next.pathname, {\n      strictParseParams: true,\n    })\n\n    await this.loadMatches(matches, next, {\n      preload: true,\n    })\n    return matches\n  }\n\n  matchRoutes = (pathname: string, opts?: { strictParseParams?: boolean }) => {\n    const matches: AnyRouteMatch[] = []\n\n    if (!this.routeTree) {\n      return matches\n    }\n\n    const existingMatches = [\n      ...this.state.currentMatches,\n      ...(this.state.pendingMatches ?? []),\n    ]\n\n    const findInRouteTree = async (\n      routes: Route<any, any>[],\n    ): Promise<void> => {\n      const parentMatch = last(matches)\n      let params = parentMatch?.params ?? {}\n\n      const filteredRoutes = this.options.filterRoutes?.(routes) ?? routes\n\n      let matchingRoutes: Route[] = []\n\n      const findMatchInRoutes = (parentRoutes: Route[], routes: Route[]) => {\n        routes.some((route) => {\n          const children = route.children as undefined | Route[]\n          if (!route.path && children?.length) {\n            return findMatchInRoutes(\n              [...matchingRoutes, route],\n              children as any,\n            )\n          }\n\n          const fuzzy = !!(route.path !== '/' || children?.length)\n\n          const matchParams = matchPathname(this.basepath, pathname, {\n            to: route.fullPath,\n            fuzzy,\n            caseSensitive:\n              route.options.caseSensitive ?? this.options.caseSensitive,\n          })\n\n          if (matchParams) {\n            let parsedParams\n\n            try {\n              parsedParams =\n                route.options.parseParams?.(matchParams!) ?? matchParams\n            } catch (err) {\n              if (opts?.strictParseParams) {\n                throw err\n              }\n            }\n\n            params = {\n              ...params,\n              ...parsedParams,\n            }\n          }\n\n          if (!!matchParams) {\n            matchingRoutes = [...parentRoutes, route]\n          }\n\n          return !!matchingRoutes.length\n        })\n\n        return !!matchingRoutes.length\n      }\n\n      findMatchInRoutes([], filteredRoutes)\n\n      if (!matchingRoutes.length) {\n        return\n      }\n\n      matchingRoutes.forEach((foundRoute) => {\n        const interpolatedPath = interpolatePath(foundRoute.path, params)\n        const matchId = interpolatePath(foundRoute.id, params, true)\n\n        const match =\n          existingMatches.find((d) => d.id === matchId) ||\n          new RouteMatch(this, foundRoute, {\n            id: matchId,\n            params,\n            pathname: joinPaths([this.basepath, interpolatedPath]),\n          })\n\n        matches.push(match)\n      })\n\n      const foundRoute = last(matchingRoutes)!\n\n      const foundChildren = foundRoute.children as any\n\n      if (foundChildren?.length) {\n        findInRouteTree(foundChildren)\n      }\n    }\n\n    findInRouteTree([this.routeTree as any])\n\n    return matches\n  }\n\n  loadMatches = async (\n    resolvedMatches: RouteMatch[],\n    location: ParsedLocation,\n    opts?: {\n      preload?: boolean\n      // filter?: (match: RouteMatch<any, any>) => any\n    },\n  ) => {\n    let firstBadMatchIndex: number | undefined\n\n    // Check each match middleware to see if the route can be accessed\n    try {\n      await Promise.all(\n        resolvedMatches.map(async (match, index) => {\n          try {\n            await match.route.options.beforeLoad?.({\n              router: this as any,\n              match,\n            })\n          } catch (err) {\n            if (isRedirect(err)) {\n              throw err\n            }\n\n            firstBadMatchIndex = firstBadMatchIndex ?? index\n\n            const errorHandler =\n              match.route.options.onBeforeLoadError ??\n              match.route.options.onError\n            try {\n              errorHandler?.(err)\n            } catch (errorHandlerErr) {\n              if (isRedirect(errorHandlerErr)) {\n                throw errorHandlerErr\n              }\n\n              match.__store.setState((s) => ({\n                ...s,\n                error: errorHandlerErr,\n                status: 'error',\n                updatedAt: Date.now(),\n              }))\n              return\n            }\n\n            match.__store.setState((s) => ({\n              ...s,\n              error: err,\n              status: 'error',\n              updatedAt: Date.now(),\n            }))\n          }\n        }),\n      )\n    } catch (err) {\n      if (isRedirect(err)) {\n        if (!opts?.preload) {\n          this.navigate(err as any)\n        }\n        return\n      }\n\n      throw err // we should never end up here\n    }\n\n    const validResolvedMatches = resolvedMatches.slice(0, firstBadMatchIndex)\n    const matchPromises = validResolvedMatches.map(async (match, index) => {\n      const parentMatch = validResolvedMatches[index - 1]\n\n      match.__load({ preload: opts?.preload, location, parentMatch })\n\n      await match.__loadPromise\n\n      if (parentMatch) {\n        await parentMatch.__loadPromise\n      }\n    })\n\n    await Promise.all(matchPromises)\n  }\n\n  reload = () => {\n    this.navigate({\n      fromCurrent: true,\n      replace: true,\n      search: true,\n    } as any)\n  }\n\n  resolvePath = (from: string, path: string) => {\n    return resolvePath(this.basepath!, from, cleanPath(path))\n  }\n\n  navigate = async <\n    TFrom extends ValidFromPath<TRoutesInfo> = '/',\n    TTo extends string = '',\n  >({\n    from,\n    to = '' as any,\n    search,\n    hash,\n    replace,\n    params,\n  }: NavigateOptions<TRoutesInfo, TFrom, TTo>) => {\n    // If this link simply reloads the current route,\n    // make sure it has a new key so it will trigger a data refresh\n\n    // If this `to` is a valid external URL, return\n    // null for LinkUtils\n    const toString = String(to)\n    const fromString = typeof from === 'undefined' ? from : String(from)\n    let isExternal\n\n    try {\n      new URL(`${toString}`)\n      isExternal = true\n    } catch (e) {}\n\n    invariant(\n      !isExternal,\n      'Attempting to navigate to external url with this.navigate!',\n    )\n\n    return this.#commitLocation({\n      from: fromString,\n      to: toString,\n      search,\n      hash,\n      replace,\n      params,\n    })\n  }\n\n  matchRoute = <\n    TFrom extends ValidFromPath<TRoutesInfo> = '/',\n    TTo extends string = '',\n    TResolved extends string = ResolveRelativePath<TFrom, NoInfer<TTo>>,\n  >(\n    location: ToOptions<TRoutesInfo, TFrom, TTo>,\n    opts?: MatchRouteOptions,\n  ): false | TRoutesInfo['routesById'][TResolved]['__types']['allParams'] => {\n    location = {\n      ...location,\n      to: location.to\n        ? this.resolvePath(location.from ?? '', location.to)\n        : undefined,\n    } as any\n\n    const next = this.buildNext(location)\n    const baseLocation = opts?.pending\n      ? this.state.pendingLocation\n      : this.state.currentLocation\n\n    if (!baseLocation) {\n      return false\n    }\n\n    const match = matchPathname(this.basepath, baseLocation.pathname, {\n      ...opts,\n      to: next.pathname,\n    }) as any\n\n    if (!match) {\n      return false\n    }\n\n    if (opts?.includeSearch ?? true) {\n      return partialDeepEqual(baseLocation.search, next.search) ? match : false\n    }\n\n    return match\n  }\n\n  buildLink = <\n    TFrom extends ValidFromPath<TRoutesInfo> = '/',\n    TTo extends string = '',\n  >({\n    from,\n    to = '.' as any,\n    search,\n    params,\n    hash,\n    target,\n    replace,\n    activeOptions,\n    preload,\n    preloadDelay: userPreloadDelay,\n    disabled,\n  }: LinkOptions<TRoutesInfo, TFrom, TTo>): LinkInfo => {\n    // If this link simply reloads the current route,\n    // make sure it has a new key so it will trigger a data refresh\n\n    // If this `to` is a valid external URL, return\n    // null for LinkUtils\n\n    try {\n      new URL(`${to}`)\n      return {\n        type: 'external',\n        href: to,\n      }\n    } catch (e) {}\n\n    const nextOpts = {\n      from,\n      to,\n      search,\n      params,\n      hash,\n      replace,\n    }\n\n    const next = this.buildNext(nextOpts)\n\n    preload = preload ?? this.options.defaultPreload\n    const preloadDelay =\n      userPreloadDelay ?? this.options.defaultPreloadDelay ?? 0\n\n    // Compare path/hash for matches\n    const currentPathSplit = this.state.currentLocation.pathname.split('/')\n    const nextPathSplit = next.pathname.split('/')\n    const pathIsFuzzyEqual = nextPathSplit.every(\n      (d, i) => d === currentPathSplit[i],\n    )\n    // Combine the matches based on user options\n    const pathTest = activeOptions?.exact\n      ? this.state.currentLocation.pathname === next.pathname\n      : pathIsFuzzyEqual\n    const hashTest = activeOptions?.includeHash\n      ? this.state.currentLocation.hash === next.hash\n      : true\n    const searchTest =\n      activeOptions?.includeSearch ?? true\n        ? partialDeepEqual(this.state.currentLocation.search, next.search)\n        : true\n\n    // The final \"active\" test\n    const isActive = pathTest && hashTest && searchTest\n\n    // The click handler\n    const handleClick = (e: MouseEvent) => {\n      if (\n        !disabled &&\n        !isCtrlEvent(e) &&\n        !e.defaultPrevented &&\n        (!target || target === '_self') &&\n        e.button === 0\n      ) {\n        e.preventDefault()\n\n        // All is well? Navigate!\n        this.#commitLocation(nextOpts as any)\n      }\n    }\n\n    // The click handler\n    const handleFocus = (e: MouseEvent) => {\n      if (preload) {\n        this.preloadRoute(nextOpts).catch((err) => {\n          console.warn(err)\n          console.warn('Error preloading route! ☝️')\n        })\n      }\n    }\n\n    const handleTouchStart = (e: TouchEvent) => {\n      this.preloadRoute(nextOpts).catch((err) => {\n        console.warn(err)\n        console.warn('Error preloading route! ☝️')\n      })\n    }\n\n    const handleEnter = (e: MouseEvent) => {\n      const target = (e.target || {}) as LinkCurrentTargetElement\n\n      if (preload) {\n        if (target.preloadTimeout) {\n          return\n        }\n\n        target.preloadTimeout = setTimeout(() => {\n          target.preloadTimeout = null\n          this.preloadRoute(nextOpts).catch((err) => {\n            console.warn(err)\n            console.warn('Error preloading route! ☝️')\n          })\n        }, preloadDelay)\n      }\n    }\n\n    const handleLeave = (e: MouseEvent) => {\n      const target = (e.target || {}) as LinkCurrentTargetElement\n\n      if (target.preloadTimeout) {\n        clearTimeout(target.preloadTimeout)\n        target.preloadTimeout = null\n      }\n    }\n\n    return {\n      type: 'internal',\n      next,\n      handleFocus,\n      handleClick,\n      handleEnter,\n      handleLeave,\n      handleTouchStart,\n      isActive,\n      disabled,\n    }\n  }\n\n  // dehydrate = (): DehydratedRouter => {\n  //   return {\n  //     state: {\n  //       ...pick(this.state, [\n  //         'latestLocation',\n  //         'currentLocation',\n  //         'status',\n  //         'lastUpdated',\n  //       ]),\n  //       // currentMatches: this.state.currentMatches.map((match) => ({\n  //       //   id: match.id,\n  //       //   state: {\n  //       //     status: match.state.status,\n  //       //     // status: 'idle',\n  //       //   },\n  //       // })),\n  //     },\n  //   }\n  // }\n\n  // hydrate = (dehydratedRouter: DehydratedRouter) => {\n  //   this.__store.setState((s) => {\n  //     // Match the routes\n  //     // const currentMatches = this.matchRoutes(\n  //     //   dehydratedRouter.state.latestLocation.pathname,\n  //     //   {\n  //     //     strictParseParams: true,\n  //     //   },\n  //     // )\n\n  //     // currentMatches.forEach((match, index) => {\n  //     // const dehydratedMatch = dehydratedRouter.state.currentMatches[index]\n  //     // invariant(\n  //     //   dehydratedMatch && dehydratedMatch.id === match.id,\n  //     //   'Oh no! There was a hydration mismatch when attempting to hydrate the state of the router! 😬',\n  //     // )\n  //     // match.__store.setState((s) => ({\n  //     //   ...s,\n  //     //   ...dehydratedMatch.state,\n  //     // }))\n  //     // })\n\n  //     return {\n  //       ...s,\n  //       ...dehydratedRouter.state,\n  //       // currentMatches,\n  //     }\n  //   })\n  // }\n\n  #buildRouteTree = (routeTree: AnyRoute) => {\n    const recurseRoutes = (routes: Route[], parentRoute: Route | undefined) => {\n      routes.forEach((route, i) => {\n        route.init({ originalIndex: i, router: this })\n\n        const existingRoute = (this.routesById as any)[route.id]\n\n        invariant(\n          !existingRoute,\n          `Duplicate routes found with id: ${String(route.id)}`,\n        )\n        ;(this.routesById as any)[route.id] = route\n\n        const children = route.children as Route[]\n\n        if (children?.length) {\n          recurseRoutes(children, route)\n\n          route.children = children\n            .map((d, i) => {\n              const parsed = parsePathname(\n                trimPathLeft(cleanPath(d.path ?? '/')),\n              )\n\n              while (parsed.length > 1 && parsed[0]?.value === '/') {\n                parsed.shift()\n              }\n\n              let score = 0\n\n              parsed.forEach((d, i) => {\n                let modifier = 1\n                while (i--) {\n                  modifier *= 0.001\n                }\n                if (d.type === 'pathname' && d.value !== '/') {\n                  score += 1 * modifier\n                } else if (d.type === 'param') {\n                  score += 2 * modifier\n                } else if (d.type === 'wildcard') {\n                  score += 3 * modifier\n                }\n              })\n\n              return { child: d, parsed, index: i, score }\n            })\n            .sort((a, b) => {\n              if (a.score !== b.score) {\n                return a.score - b.score\n              }\n\n              return a.index - b.index\n            })\n            .map((d) => d.child)\n        }\n      })\n    }\n\n    recurseRoutes([routeTree] as Route[], undefined)\n\n    const recurceCheckRoutes = (\n      routes: Route[],\n      parentRoute: Route | undefined,\n    ) => {\n      routes.forEach((route) => {\n        if (route.isRoot) {\n          invariant(\n            !parentRoute,\n            'Root routes can only be used as the root of a route tree.',\n          )\n        } else {\n          invariant(\n            parentRoute ? route.parentRoute === parentRoute : true,\n            `Expected a route with path \"${route.path}\" to be passed to its parent route \"${route.parentRoute?.id}\" in an addChildren() call, but was instead passed as a child of the \"${parentRoute?.id}\" route.`,\n          )\n        }\n\n        if (route.children) {\n          recurceCheckRoutes(route.children as Route[], route)\n        }\n      })\n    }\n\n    recurceCheckRoutes([routeTree] as Route[], undefined)\n\n    return routeTree\n  }\n\n  #parseLocation = (previousLocation?: ParsedLocation): ParsedLocation => {\n    let { pathname, search, hash, state } = this.history.location\n\n    const parsedSearch = this.options.parseSearch(search)\n\n    return {\n      pathname: pathname,\n      searchStr: search,\n      search: replaceEqualDeep(previousLocation?.search, parsedSearch),\n      hash: hash.split('#').reverse()[0] ?? '',\n      href: `${pathname}${search}${hash}`,\n      state: state as LocationState,\n      key: state?.key || '__init__',\n    }\n  }\n\n  #buildLocation = (dest: BuildNextOptions = {}): ParsedLocation => {\n    dest.fromCurrent = dest.fromCurrent ?? dest.to === ''\n\n    const fromPathname = dest.fromCurrent\n      ? this.state.latestLocation.pathname\n      : dest.from ?? this.state.latestLocation.pathname\n\n    let pathname = resolvePath(\n      this.basepath ?? '/',\n      fromPathname,\n      `${dest.to ?? ''}`,\n    )\n\n    const fromMatches = this.matchRoutes(this.state.latestLocation.pathname, {\n      strictParseParams: true,\n    })\n\n    const prevParams = { ...last(fromMatches)?.params }\n\n    let nextParams =\n      (dest.params ?? true) === true\n        ? prevParams\n        : functionalUpdate(dest.params!, prevParams)\n\n    if (nextParams) {\n      dest.__matches\n        ?.map((d) => d.route.options.stringifyParams)\n        .filter(Boolean)\n        .forEach((fn) => {\n          nextParams = { ...nextParams!, ...fn!(nextParams!) }\n        })\n    }\n\n    pathname = interpolatePath(pathname, nextParams ?? {})\n\n    const preSearchFilters =\n      dest.__matches\n        ?.map((match) => match.route.options.preSearchFilters ?? [])\n        .flat()\n        .filter(Boolean) ?? []\n\n    const postSearchFilters =\n      dest.__matches\n        ?.map((match) => match.route.options.postSearchFilters ?? [])\n        .flat()\n        .filter(Boolean) ?? []\n\n    // Pre filters first\n    const preFilteredSearch = preSearchFilters?.length\n      ? preSearchFilters?.reduce(\n          (prev, next) => next(prev),\n          this.state.latestLocation.search,\n        )\n      : this.state.latestLocation.search\n\n    // Then the link/navigate function\n    const destSearch =\n      dest.search === true\n        ? preFilteredSearch // Preserve resolvedFrom true\n        : dest.search\n        ? functionalUpdate(dest.search, preFilteredSearch) ?? {} // Updater\n        : preSearchFilters?.length\n        ? preFilteredSearch // Preserve resolvedFrom filters\n        : {}\n\n    // Then post filters\n    const postFilteredSearch = postSearchFilters?.length\n      ? postSearchFilters.reduce((prev, next) => next(prev), destSearch)\n      : destSearch\n\n    const search = replaceEqualDeep(\n      this.state.latestLocation.search,\n      postFilteredSearch,\n    )\n\n    const searchStr = this.options.stringifySearch(search)\n    let hash =\n      dest.hash === true\n        ? this.state.latestLocation.hash\n        : functionalUpdate(dest.hash!, this.state.latestLocation.hash)\n    hash = hash ? `#${hash}` : ''\n\n    const nextState =\n      dest.state === true\n        ? this.state.latestLocation.state\n        : functionalUpdate(dest.state, this.state.latestLocation.state)!\n\n    return {\n      pathname,\n      search,\n      searchStr,\n      state: nextState,\n      hash,\n      href: this.history.createHref(`${pathname}${searchStr}${hash}`),\n      key: dest.key,\n    }\n  }\n\n  #commitLocation = async (\n    location: BuildNextOptions & { replace?: boolean },\n  ) => {\n    const next = this.buildNext(location)\n    const id = '' + Date.now() + Math.random()\n\n    if (this.navigateTimeout) clearTimeout(this.navigateTimeout)\n\n    let nextAction: 'push' | 'replace' = 'replace'\n\n    if (!location.replace) {\n      nextAction = 'push'\n    }\n\n    const isSameUrl = this.state.latestLocation.href === next.href\n\n    if (isSameUrl && !next.key) {\n      nextAction = 'replace'\n    }\n\n    const href = `${next.pathname}${next.searchStr}${\n      next.hash ? `${next.hash}` : ''\n    }`\n\n    this.history[nextAction === 'push' ? 'push' : 'replace'](href, {\n      id,\n      ...next.state,\n    })\n\n    return (this.navigationPromise = new Promise((resolve) => {\n      const previousNavigationResolve = this.resolveNavigation\n\n      this.resolveNavigation = () => {\n        previousNavigationResolve()\n        resolve()\n      }\n    }))\n  }\n}\n\n// Detect if we're in the DOM\nconst isServer = typeof window === 'undefined' || !window.document.createElement\n\nfunction getInitialRouterState(): RouterState<any, any> {\n  return {\n    status: 'idle',\n    latestLocation: null!,\n    currentLocation: null!,\n    currentMatches: [],\n    lastUpdated: Date.now(),\n  }\n}\n\nfunction isCtrlEvent(e: MouseEvent) {\n  return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)\n}\n\nexport type AnyRedirect = Redirect<any, any, any>\n\nexport type Redirect<\n  TRoutesInfo extends AnyRoutesInfo = RegisteredRoutesInfo,\n  TFrom extends TRoutesInfo['routePaths'] = '/',\n  TTo extends string = '',\n> = NavigateOptions<TRoutesInfo, TFrom, TTo> & {\n  code?: number\n}\n\nexport function redirect<\n  TRoutesInfo extends AnyRoutesInfo = RegisteredRoutesInfo,\n  TFrom extends TRoutesInfo['routePaths'] = '/',\n  TTo extends string = '',\n>(opts: Redirect<TRoutesInfo, TFrom, TTo>): Redirect<TRoutesInfo, TFrom, TTo> {\n  ;(opts as any).isRedirect = true\n  return opts\n}\n\nexport function isRedirect(obj: any): obj is AnyRedirect {\n  return !!obj?.isRedirect\n}\n", "import { Store } from '@tanstack/react-store'\n//\nimport { RouteComponent } from './react'\nimport { AnyRoute, Route } from './route'\nimport { AnyRoutesInfo, DefaultRoutesInfo } from './routeInfo'\nimport { AnyRouter, isRedirect, ParsedLocation, Router } from './router'\nimport { replaceEqualDeep } from './utils'\n\nexport interface RouteMatchState<\n  TRoutesInfo extends AnyRoutesInfo = DefaultRoutesInfo,\n  TRoute extends AnyRoute = Route,\n> {\n  routeSearch: TRoute['__types']['searchSchema']\n  search: TRoutesInfo['fullSearchSchema'] &\n    TRoute['__types']['fullSearchSchema']\n  status: 'idle' | 'pending' | 'success' | 'error'\n  error?: unknown\n  updatedAt: number\n  loader: TRoute['__types']['loader']\n}\n\nconst componentTypes = [\n  'component',\n  'errorComponent',\n  'pendingComponent',\n] as const\n\nexport interface PendingRouteMatchInfo {\n  state: RouteMatchState<any, any>\n  routeContext: {}\n  context: {}\n}\n\nexport interface AnyRouteMatch extends RouteMatch<any, any> {}\n\nexport class RouteMatch<\n  TRoutesInfo extends AnyRoutesInfo = DefaultRoutesInfo,\n  TRoute extends AnyRoute = AnyRoute,\n> {\n  route!: TRoute\n  router!: Router<TRoutesInfo['routeTree'], TRoutesInfo>\n  __store!: Store<RouteMatchState<TRoutesInfo, TRoute>>\n  state!: RouteMatchState<TRoutesInfo, TRoute>\n  id!: string\n  pathname!: string\n  params!: TRoute['__types']['allParams']\n\n  routeContext?: TRoute['__types']['routeContext']\n  context!: TRoute['__types']['context']\n\n  component?: RouteComponent<{\n    useLoader: TRoute['useLoader']\n    useMatch: TRoute['useMatch']\n    useContext: TRoute['useContext']\n    useSearch: TRoute['useSearch']\n  }>\n  errorComponent?: RouteComponent<{\n    error: Error\n    info: { componentStack: string }\n  }>\n  pendingComponent?: RouteComponent\n  abortController = new AbortController()\n  parentMatch?: RouteMatch\n  pendingInfo?: PendingRouteMatchInfo\n\n  __loadPromise?: Promise<void>\n  __onExit?:\n    | void\n    | ((matchContext: {\n        params: TRoute['__types']['allParams']\n        search: TRoute['__types']['fullSearchSchema']\n      }) => void)\n\n  constructor(\n    router: AnyRouter,\n    route: TRoute,\n    opts: {\n      id: string\n      params: TRoute['__types']['allParams']\n      pathname: string\n    },\n  ) {\n    Object.assign(this, {\n      route,\n      router,\n      id: opts.id,\n      pathname: opts.pathname,\n      params: opts.params,\n      __store: new Store<RouteMatchState<TRoutesInfo, TRoute>>(\n        {\n          updatedAt: 0,\n          routeSearch: {},\n          search: {} as any,\n          status: 'idle',\n          loader: undefined,\n        },\n        {\n          onUpdate: (next) => {\n            this.state = next\n          },\n        },\n      ),\n    })\n\n    this.state = this.__store.state\n\n    componentTypes.map(async (type) => {\n      const component = this.route.options[type]\n\n      this[type] = component as any\n    })\n\n    if (this.state.status === 'idle' && !this.#hasLoaders()) {\n      this.__store.setState((s) => ({\n        ...s,\n        status: 'success',\n      }))\n    }\n  }\n\n  #hasLoaders = () => {\n    return !!(\n      this.route.options.loader ||\n      componentTypes.some((d) => this.route.options[d]?.preload)\n    )\n  }\n\n  __commit = () => {\n    const { routeSearch, search, context, routeContext } = this.#resolveInfo({\n      location: this.router.state.currentLocation,\n    })\n    this.context = context\n    this.routeContext = routeContext\n    this.__store.setState((s) => ({\n      ...s,\n      routeSearch: replaceEqualDeep(s.routeSearch, routeSearch),\n      search: replaceEqualDeep(s.search, search),\n    }))\n  }\n\n  cancel = () => {\n    this.abortController?.abort()\n  }\n\n  #resolveSearchInfo = (opts: {\n    location: ParsedLocation\n  }): { routeSearch: {}; search: {} } => {\n    // Validate the search params and stabilize them\n    const parentSearchInfo = this.parentMatch\n      ? this.parentMatch.#resolveSearchInfo(opts)\n      : { search: opts.location.search, routeSearch: opts.location.search }\n\n    try {\n      const validator =\n        typeof this.route.options.validateSearch === 'object'\n          ? this.route.options.validateSearch.parse\n          : this.route.options.validateSearch\n\n      const routeSearch = validator?.(parentSearchInfo.search) ?? {}\n\n      const search = {\n        ...parentSearchInfo.search,\n        ...routeSearch,\n      }\n\n      return {\n        routeSearch,\n        search,\n      }\n    } catch (err: any) {\n      if (isRedirect(err)) {\n        throw err\n      }\n\n      const errorHandler =\n        this.route.options.onValidateSearchError ?? this.route.options.onError\n      errorHandler?.(err)\n      const error = new (Error as any)('Invalid search params found', {\n        cause: err,\n      })\n      error.code = 'INVALID_SEARCH_PARAMS'\n\n      throw error\n    }\n  }\n\n  #resolveInfo = (opts: { location: ParsedLocation }) => {\n    const { search, routeSearch } = this.#resolveSearchInfo(opts)\n\n    try {\n      const routeContext =\n        this.route.options.getContext?.({\n          parentContext: this.parentMatch?.routeContext ?? {},\n          context:\n            this.parentMatch?.context ?? this.router?.options.context ?? {},\n          params: this.params,\n          search,\n        }) || ({} as any)\n\n      const context = {\n        ...(this.parentMatch?.context ?? this.router?.options.context),\n        ...routeContext,\n      } as any\n\n      return {\n        routeSearch,\n        search,\n        context,\n        routeContext,\n      }\n    } catch (err) {\n      this.route.options.onError?.(err)\n      throw err\n    }\n  }\n\n  __load = async (opts: {\n    parentMatch: RouteMatch | undefined\n    preload?: boolean\n    location: ParsedLocation\n  }): Promise<void> => {\n    this.parentMatch = opts.parentMatch\n\n    let info\n\n    try {\n      info = this.#resolveInfo(opts)\n    } catch (err) {\n      if (isRedirect(err)) {\n        if (!opts?.preload) {\n          this.router.navigate(err as any)\n        }\n        return\n      }\n\n      this.__store.setState((s) => ({\n        ...s,\n        status: 'error',\n        error: err,\n      }))\n\n      // Do not proceed with loading the route\n      return\n    }\n\n    const { routeSearch, search, context, routeContext } = info\n\n    // If the match is invalid, errored or idle, trigger it to load\n    if (this.state.status === 'pending') {\n      return\n    }\n\n    this.__loadPromise = Promise.resolve().then(async () => {\n      const loadId = '' + Date.now() + Math.random()\n      this.#latestId = loadId\n\n      const checkLatest = () => {\n        return loadId !== this.#latestId ? this.__loadPromise : undefined\n      }\n\n      let latestPromise\n\n      // If the match was in an error state, set it\n      // to a loading state again. Otherwise, keep it\n      // as loading or resolved\n      if (this.state.status === 'idle') {\n        this.__store.setState((s) => ({\n          ...s,\n          status: 'pending',\n        }))\n      }\n\n      const componentsPromise = (async () => {\n        // then run all component and data loaders in parallel\n        // For each component type, potentially load it asynchronously\n\n        await Promise.all(\n          componentTypes.map(async (type) => {\n            const component = this.route.options[type]\n\n            if (component?.preload) {\n              await component.preload()\n            }\n          }),\n        )\n      })()\n\n      const loaderPromise = Promise.resolve().then(() => {\n        if (this.route.options.loader) {\n          return this.route.options.loader({\n            params: this.params,\n            routeSearch,\n            search,\n            signal: this.abortController.signal,\n            preload: !!opts?.preload,\n            routeContext: routeContext,\n            context: context,\n          })\n        }\n        return\n      })\n\n      try {\n        const [_, loader] = await Promise.all([\n          componentsPromise,\n          loaderPromise,\n        ])\n        if ((latestPromise = checkLatest())) return await latestPromise\n        this.__store.setState((s) => ({\n          ...s,\n          error: undefined,\n          status: 'success',\n          updatedAt: Date.now(),\n          loader,\n        }))\n      } catch (err) {\n        if (isRedirect(err)) {\n          if (!opts?.preload) {\n            this.router.navigate(err as any)\n          }\n          return\n        }\n\n        const errorHandler =\n          this.route.options.onLoadError ?? this.route.options.onError\n        try {\n          errorHandler?.(err)\n        } catch (errorHandlerErr) {\n          if (isRedirect(errorHandlerErr)) {\n            if (!opts?.preload) {\n              this.router.navigate(errorHandlerErr as any)\n            }\n            return\n          }\n\n          this.__store.setState((s) => ({\n            ...s,\n            error: errorHandlerErr,\n            status: 'error',\n            updatedAt: Date.now(),\n          }))\n          return\n        }\n\n        this.__store.setState((s) => ({\n          ...s,\n          error: err,\n          status: 'error',\n          updatedAt: Date.now(),\n        }))\n      } finally {\n        delete this.__loadPromise\n      }\n    })\n\n    return this.__loadPromise\n  }\n\n  #latestId = ''\n}\n"],
  "mappings": "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",
  "names": ["React", "useState", "useEffect", "useLayoutEffect", "error", "React", "useRef", "useEffect", "useSyncExternalStoreWithSelector", "isProduction", "Store", "constructor", "initialState", "options", "listeners", "Set", "subscribe", "listener", "add", "unsub", "onSubscribe", "delete", "setState", "updater", "previous", "state", "updateFn", "onUpdate", "flushId", "forEach", "batch", "cb", "useStore", "store", "selector", "d", "slice", "useSyncExternalStoreWithSelector", "subscribe", "state", "shallow", "objA", "objB", "Object", "is", "keysA", "keys", "length", "i", "prototype", "hasOwnProperty", "call", "popStateEvent", "beforeUnloadEvent", "beforeUnloadListener", "event", "preventDefault", "returnValue", "stopBlocking", "removeEventListener", "capture", "createHistory", "opts", "currentLocation", "getLocation", "unsub", "listeners", "Set", "blockers", "queue", "tryFlush", "length", "shift", "onUpdate", "queueTask", "task", "push", "forEach", "listener", "location", "listen", "cb", "size", "add", "delete", "path", "state", "pushState", "replace", "replaceState", "go", "index", "back", "forward", "createHref", "str", "block", "addEventListener", "filter", "b", "createBrowserHistory", "getHref", "window", "pathname", "hash", "search", "parseLocation", "history", "key", "createRandomKey", "n", "createHashHistory", "substring", "createMemoryHistory", "initialEntries", "entries", "initialIndex", "currentState", "Math", "min", "href", "hashIndex", "indexOf", "searchIndex", "random", "toString", "last", "arr", "isFunction", "d", "functionalUpdate", "updater", "previous", "pick", "parent", "keys", "reduce", "obj", "replaceEqualDeep", "prev", "_next", "next", "array", "Array", "isArray", "isPlainObject", "prevSize", "Object", "nextItems", "nextSize", "copy", "equalItems", "i", "o", "hasObjectPrototype", "ctor", "constructor", "prot", "prototype", "hasOwnProperty", "call", "partialDeepEqual", "a", "some", "every", "item", "joinPaths", "paths", "cleanPath", "Boolean", "join", "trimPathLeft", "trimPathRight", "trimPath", "resolvePath", "basepath", "base", "to", "RegExp", "baseSegments", "parsePathname", "toSegments", "toSegment", "value", "pop", "joined", "map", "segments", "slice", "type", "split", "part", "charAt", "interpolatePath", "params", "leaveWildcard", "interpolatedPathSegments", "segment", "includes", "matchPathname", "currentPathname", "matchLocation", "pathParams", "matchByPath", "from", "startsWith", "undefined", "routeSegments", "isMatch", "max", "baseSegment", "routeSegment", "isLastRouteSegment", "isLastBaseSegment", "caseSensitive", "toLowerCase", "fuzzy", "encode", "pfx", "k", "tmp", "encodeURIComponent", "toValue", "mix", "decodeURIComponent", "decode", "out", "concat", "lazy", "importer", "lazyComp", "finalComp", "preload", "useLinkProps", "options", "router", "useRouterContext", "children", "target", "activeProps", "className", "inactiveProps", "activeOptions", "disabled", "preloadDelay", "style", "onClick", "onFocus", "onMouseEnter", "onMouseLeave", "onTouchStart", "rest", "linkInfo", "buildLink", "handleClick", "handleFocus", "handleEnter", "handleLeave", "handleTouchStart", "isActive", "reactHandleClick", "e", "startTransition", "React", "composeHandlers", "handlers", "persist", "handler", "defaultPrevented", "resolvedActiveProps", "resolvedInactiveProps", "role", "Link", "forwardRef", "props", "ref", "linkProps", "Navigate", "useLayoutEffect", "navigate", "matchesContext", "createContext", "routerContext", "RouterProvider", "update", "currentMatches", "useStore", "__store", "s", "useEffect", "mount", "ErrorComponent", "warning", "useContext", "useRouter", "track", "useMatches", "useMatch", "nearestMatch", "match", "find", "route", "id", "invariant", "strict", "useLoader", "matchOpts", "loader", "useSearch", "useParams", "useNavigate", "defaultOpts", "useCallback", "useMatchRoute", "pending", "matchRoute", "MatchRoute", "Outlet", "matches", "SubOutlet", "store", "status", "error", "defaultPending", "PendingComponent", "pendingComponent", "defaultPendingComponent", "errorComponent", "defaultErrorComponent", "ResolvedSuspenseBoundary", "wrapInSuspense", "Suspense", "SafeFragment", "ResolvedCatchBoundary", "CatchBoundary", "Inner", "__loadPromise", "createElement", "component", "defaultComponent", "Component", "info", "componentDidCatch", "onCatch", "console", "setState", "render", "CatchBoundaryInner", "activeErrorState", "setActiveErrorState", "useState", "errorState", "prevKeyRef", "useRef", "current", "padding", "maxWidth", "fontSize", "height", "border", "borderRadius", "color", "overflow", "message", "useBlocker", "condition", "unblock", "retry", "cancel", "confirm", "Block", "rootRouteId", "Route", "init", "originalIndex", "allOptions", "isRoot", "parentRoute", "getParentRoute", "customId", "fullPath", "addChildren", "context", "RootRoute", "withRouterContext", "defaultParseSearch", "parseSearchWith", "JSON", "parse", "defaultStringifySearch", "stringifySearchWith", "stringify", "parser", "searchStr", "query", "err", "val", "defaultFetchServerDataFn", "routeMatch", "buildNext", "__data", "matchId", "res", "fetch", "method", "signal", "abortController", "ok", "json", "Error", "Router", "startedLoadingAt", "Date", "now", "resolveNavigation", "reset", "assign", "getInitialRouterState", "isServer", "safeLoad", "hydrate", "__do_not_use_server_ctx", "ctx", "document", "__DEHYDRATED__", "load", "parsedLocation", "latestLocation", "routeTree", "routesById", "__matches", "matchRoutes", "cancelMatches", "pendingMatches", "catch", "warn", "startedAt", "batch", "strictParseParams", "pendingLocation", "loadMatches", "navigationPromise", "previousMatches", "exiting", "staying", "dd", "entering", "__onExit", "routeSearch", "onTransition", "onLoaded", "prevLocation", "__commit", "onRouteChange", "getRoute", "loadRoute", "navigateOpts", "preloadRoute", "existingMatches", "findInRouteTree", "routes", "parentMatch", "filteredRoutes", "filterRoutes", "matchingRoutes", "findMatchInRoutes", "parentRoutes", "matchParams", "parsedParams", "parseParams", "foundRoute", "interpolatedPath", "RouteMatch", "foundChildren", "resolvedMatches", "firstBadMatchIndex", "Promise", "all", "beforeLoad", "isRedirect", "errorHandler", "onBeforeLoadError", "onError", "errorHandlerErr", "updatedAt", "validResolvedMatches", "matchPromises", "__load", "reload", "fromCurrent", "String", "fromString", "isExternal", "URL", "baseLocation", "includeSearch", "userPreloadDelay", "nextOpts", "defaultPreload", "defaultPreloadDelay", "currentPathSplit", "nextPathSplit", "pathIsFuzzyEqual", "pathTest", "exact", "hashTest", "includeHash", "searchTest", "isCtrlEvent", "button", "preloadTimeout", "setTimeout", "clearTimeout", "recurseRoutes", "existingRoute", "parsed", "score", "modifier", "child", "sort", "recurceCheckRoutes", "previousLocation", "parsedSearch", "parseSearch", "reverse", "dest", "fromPathname", "fromMatches", "prevParams", "nextParams", "stringifyParams", "fn", "preSearchFilters", "flat", "postSearchFilters", "preFilteredSearch", "destSearch", "postFilteredSearch", "stringifySearch", "nextState", "navigateTimeout", "nextAction", "isSameUrl", "resolve", "previousNavigationResolve", "fetchServerDataFn", "Store", "lastUpdated", "metaKey", "altKey", "ctrlKey", "shiftKey", "redirect", "componentTypes", "AbortController", "routeContext", "abort", "parentSearchInfo", "validator", "validateSearch", "onValidateSearchError", "cause", "code", "getContext", "parentContext", "then", "loadId", "checkLatest", "latestPromise", "componentsPromise", "loaderPromise", "_", "onLoadError"]
}
